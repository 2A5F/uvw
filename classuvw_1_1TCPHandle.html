<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>uvw: uvw::TCPHandle Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">uvw
   &#160;<span id="projectnumber">1.17.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceuvw.html">uvw</a></li><li class="navelem"><a class="el" href="classuvw_1_1TCPHandle.html">TCPHandle</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classuvw_1_1TCPHandle-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">uvw::TCPHandle Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classuvw_1_1TCPHandle.html" title="The TCPHandle handle. ">TCPHandle</a> handle.  
 <a href="classuvw_1_1TCPHandle.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="tcp_8hpp_source.html">tcp.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for uvw::TCPHandle:</div>
<div class="dyncontent">
<div class="center"><img src="classuvw_1_1TCPHandle__inherit__graph.png" border="0" usemap="#uvw_1_1TCPHandle_inherit__map" alt="Inheritance graph"/></div>
<map name="uvw_1_1TCPHandle_inherit__map" id="uvw_1_1TCPHandle_inherit__map">
<area shape="rect" id="node2" href="classuvw_1_1StreamHandle.html" title="uvw::StreamHandle\&lt;\l TCPHandle, uv_tcp_t \&gt;" alt="" coords="78,273,242,315"/>
<area shape="rect" id="node3" href="classuvw_1_1Handle.html" title="uvw::Handle\&lt; TCPHandle,\l uv_tcp_t \&gt;" alt="" coords="71,184,249,225"/>
<area shape="rect" id="node4" href="structuvw_1_1BaseHandle.html" title="Untyped handle class. " alt="" coords="5,102,131,129"/>
<area shape="rect" id="node5" href="classuvw_1_1Resource.html" title="uvw::Resource\&lt; TCPHandle,\l uv_tcp_t \&gt;" alt="" coords="155,95,349,136"/>
<area shape="rect" id="node6" href="classuvw_1_1UnderlyingType.html" title="uvw::UnderlyingType\l\&lt; TCPHandle, uv_tcp_t \&gt;" alt="" coords="63,5,235,47"/>
<area shape="rect" id="node7" href="classuvw_1_1Emitter.html" title="uvw::Emitter\&lt; TCPHandle \&gt;" alt="" coords="259,13,447,39"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for uvw::TCPHandle:</div>
<div class="dyncontent">
<div class="center"><img src="classuvw_1_1TCPHandle__coll__graph.png" border="0" usemap="#uvw_1_1TCPHandle_coll__map" alt="Collaboration graph"/></div>
<map name="uvw_1_1TCPHandle_coll__map" id="uvw_1_1TCPHandle_coll__map">
<area shape="rect" id="node2" href="classuvw_1_1StreamHandle.html" title="uvw::StreamHandle\&lt;\l TCPHandle, uv_tcp_t \&gt;" alt="" coords="78,273,242,315"/>
<area shape="rect" id="node3" href="classuvw_1_1Handle.html" title="uvw::Handle\&lt; TCPHandle,\l uv_tcp_t \&gt;" alt="" coords="71,184,249,225"/>
<area shape="rect" id="node4" href="structuvw_1_1BaseHandle.html" title="Untyped handle class. " alt="" coords="5,102,131,129"/>
<area shape="rect" id="node5" href="classuvw_1_1Resource.html" title="uvw::Resource\&lt; TCPHandle,\l uv_tcp_t \&gt;" alt="" coords="155,95,349,136"/>
<area shape="rect" id="node6" href="classuvw_1_1UnderlyingType.html" title="uvw::UnderlyingType\l\&lt; TCPHandle, uv_tcp_t \&gt;" alt="" coords="63,5,235,47"/>
<area shape="rect" id="node7" href="classuvw_1_1Emitter.html" title="uvw::Emitter\&lt; TCPHandle \&gt;" alt="" coords="259,13,447,39"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1e4b789c4071720ba05fd89adfcb4e41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1TCPHandle.html#a1e4b789c4071720ba05fd89adfcb4e41">init</a> ()</td></tr>
<tr class="memdesc:a1e4b789c4071720ba05fd89adfcb4e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the handle. No socket is created as of yet.  <a href="#a1e4b789c4071720ba05fd89adfcb4e41">More...</a><br /></td></tr>
<tr class="separator:a1e4b789c4071720ba05fd89adfcb4e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32fc3f653d1d920fffeae485b3237281"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1TCPHandle.html#a32fc3f653d1d920fffeae485b3237281">open</a> (<a class="el" href="namespaceuvw.html#a2df38e5bba10fc959ef37074cf580097">OSSocketHandle</a> socket)</td></tr>
<tr class="memdesc:a32fc3f653d1d920fffeae485b3237281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens an existing file descriptor or SOCKET as a TCP handle.  <a href="#a32fc3f653d1d920fffeae485b3237281">More...</a><br /></td></tr>
<tr class="separator:a32fc3f653d1d920fffeae485b3237281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3837999138b3450036f3631b009b2c71"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1TCPHandle.html#a3837999138b3450036f3631b009b2c71">noDelay</a> (bool value=false)</td></tr>
<tr class="memdesc:a3837999138b3450036f3631b009b2c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables/Disables Nagleâ€™s algorithm.  <a href="#a3837999138b3450036f3631b009b2c71">More...</a><br /></td></tr>
<tr class="separator:a3837999138b3450036f3631b009b2c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b628dd0ccddf127860e3c7ee5b3c18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1TCPHandle.html#a37b628dd0ccddf127860e3c7ee5b3c18">keepAlive</a> (bool enable=false, Time time=Time{0})</td></tr>
<tr class="memdesc:a37b628dd0ccddf127860e3c7ee5b3c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables/Disables TCP keep-alive.  <a href="#a37b628dd0ccddf127860e3c7ee5b3c18">More...</a><br /></td></tr>
<tr class="separator:a37b628dd0ccddf127860e3c7ee5b3c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6615582d687d7405b4b6930598ab5a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1TCPHandle.html#a5a6615582d687d7405b4b6930598ab5a">simultaneousAccepts</a> (bool enable=true)</td></tr>
<tr class="memdesc:a5a6615582d687d7405b4b6930598ab5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables/Disables simultaneous asynchronous accept requests.  <a href="#a5a6615582d687d7405b4b6930598ab5a">More...</a><br /></td></tr>
<tr class="separator:a5a6615582d687d7405b4b6930598ab5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5c2a058049bfd064dd75b55c3ab94e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1TCPHandle.html#aca5c2a058049bfd064dd75b55c3ab94e">bind</a> (const sockaddr &amp;addr, <a class="el" href="classuvw_1_1Flags.html">Flags</a>&lt; Bind &gt; opts=<a class="el" href="classuvw_1_1Flags.html">Flags</a>&lt; Bind &gt;{})</td></tr>
<tr class="memdesc:aca5c2a058049bfd064dd75b55c3ab94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds the handle to an address and port.  <a href="#aca5c2a058049bfd064dd75b55c3ab94e">More...</a><br /></td></tr>
<tr class="separator:aca5c2a058049bfd064dd75b55c3ab94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e9caf8043042ab4de685c4d83004f3"><td class="memTemplParams" colspan="2">template&lt;typename I  = IPv4&gt; </td></tr>
<tr class="memitem:a59e9caf8043042ab4de685c4d83004f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1TCPHandle.html#a59e9caf8043042ab4de685c4d83004f3">bind</a> (std::string ip, unsigned int port, <a class="el" href="classuvw_1_1Flags.html">Flags</a>&lt; Bind &gt; opts=<a class="el" href="classuvw_1_1Flags.html">Flags</a>&lt; Bind &gt;{})</td></tr>
<tr class="memdesc:a59e9caf8043042ab4de685c4d83004f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds the handle to an address and port.  <a href="#a59e9caf8043042ab4de685c4d83004f3">More...</a><br /></td></tr>
<tr class="separator:a59e9caf8043042ab4de685c4d83004f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93739ba347c4c095e11005c247c55ec4"><td class="memTemplParams" colspan="2">template&lt;typename I  = IPv4&gt; </td></tr>
<tr class="memitem:a93739ba347c4c095e11005c247c55ec4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1TCPHandle.html#a93739ba347c4c095e11005c247c55ec4">bind</a> (<a class="el" href="structuvw_1_1Addr.html">Addr</a> addr, <a class="el" href="classuvw_1_1Flags.html">Flags</a>&lt; Bind &gt; opts=<a class="el" href="classuvw_1_1Flags.html">Flags</a>&lt; Bind &gt;{})</td></tr>
<tr class="memdesc:a93739ba347c4c095e11005c247c55ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds the handle to an address and port.  <a href="#a93739ba347c4c095e11005c247c55ec4">More...</a><br /></td></tr>
<tr class="separator:a93739ba347c4c095e11005c247c55ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1f12926ca9e108749b33cee9a6bcdf"><td class="memTemplParams" colspan="2">template&lt;typename I  = IPv4&gt; </td></tr>
<tr class="memitem:a2c1f12926ca9e108749b33cee9a6bcdf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structuvw_1_1Addr.html">Addr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1TCPHandle.html#a2c1f12926ca9e108749b33cee9a6bcdf">sock</a> () const noexcept</td></tr>
<tr class="memdesc:a2c1f12926ca9e108749b33cee9a6bcdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current address to which the handle is bound.  <a href="#a2c1f12926ca9e108749b33cee9a6bcdf">More...</a><br /></td></tr>
<tr class="separator:a2c1f12926ca9e108749b33cee9a6bcdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495c52e8e0b5210d21c0cdbdc2cf1579"><td class="memTemplParams" colspan="2">template&lt;typename I  = IPv4&gt; </td></tr>
<tr class="memitem:a495c52e8e0b5210d21c0cdbdc2cf1579"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structuvw_1_1Addr.html">Addr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1TCPHandle.html#a495c52e8e0b5210d21c0cdbdc2cf1579">peer</a> () const noexcept</td></tr>
<tr class="memdesc:a495c52e8e0b5210d21c0cdbdc2cf1579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the address of the peer connected to the handle.  <a href="#a495c52e8e0b5210d21c0cdbdc2cf1579">More...</a><br /></td></tr>
<tr class="separator:a495c52e8e0b5210d21c0cdbdc2cf1579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d3dc1999fb93d9fd6f7cc59e0946ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1TCPHandle.html#ab6d3dc1999fb93d9fd6f7cc59e0946ef">connect</a> (const sockaddr &amp;addr)</td></tr>
<tr class="memdesc:ab6d3dc1999fb93d9fd6f7cc59e0946ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes an <a class="el" href="structuvw_1_1IPv4.html" title="The IPv4 tag. ">IPv4</a> or <a class="el" href="structuvw_1_1IPv6.html" title="The IPv6 tag. ">IPv6</a> TCP connection.  <a href="#ab6d3dc1999fb93d9fd6f7cc59e0946ef">More...</a><br /></td></tr>
<tr class="separator:ab6d3dc1999fb93d9fd6f7cc59e0946ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab249951eb36140348399828d7cb96776"><td class="memTemplParams" colspan="2">template&lt;typename I  = IPv4&gt; </td></tr>
<tr class="memitem:ab249951eb36140348399828d7cb96776"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1TCPHandle.html#ab249951eb36140348399828d7cb96776">connect</a> (std::string ip, unsigned int port)</td></tr>
<tr class="memdesc:ab249951eb36140348399828d7cb96776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes an <a class="el" href="structuvw_1_1IPv4.html" title="The IPv4 tag. ">IPv4</a> or <a class="el" href="structuvw_1_1IPv6.html" title="The IPv6 tag. ">IPv6</a> TCP connection.  <a href="#ab249951eb36140348399828d7cb96776">More...</a><br /></td></tr>
<tr class="separator:ab249951eb36140348399828d7cb96776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad686cdcb361f426c60788c6f6fa48d44"><td class="memTemplParams" colspan="2">template&lt;typename I  = IPv4&gt; </td></tr>
<tr class="memitem:ad686cdcb361f426c60788c6f6fa48d44"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1TCPHandle.html#ad686cdcb361f426c60788c6f6fa48d44">connect</a> (<a class="el" href="structuvw_1_1Addr.html">Addr</a> addr)</td></tr>
<tr class="memdesc:ad686cdcb361f426c60788c6f6fa48d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes an <a class="el" href="structuvw_1_1IPv4.html" title="The IPv4 tag. ">IPv4</a> or <a class="el" href="structuvw_1_1IPv6.html" title="The IPv6 tag. ">IPv6</a> TCP connection.  <a href="#ad686cdcb361f426c60788c6f6fa48d44">More...</a><br /></td></tr>
<tr class="separator:ad686cdcb361f426c60788c6f6fa48d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classuvw_1_1StreamHandle"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classuvw_1_1StreamHandle')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classuvw_1_1StreamHandle.html">uvw::StreamHandle&lt; TCPHandle, uv_tcp_t &gt;</a></td></tr>
<tr class="memitem:a3c1a1ddd951b0087c14e951610593653 inherit pub_methods_classuvw_1_1StreamHandle"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1StreamHandle.html#a3c1a1ddd951b0087c14e951610593653">shutdown</a> ()</td></tr>
<tr class="memdesc:a3c1a1ddd951b0087c14e951610593653 inherit pub_methods_classuvw_1_1StreamHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shutdowns the outgoing (write) side of a duplex stream.  <a href="classuvw_1_1StreamHandle.html#a3c1a1ddd951b0087c14e951610593653">More...</a><br /></td></tr>
<tr class="separator:a3c1a1ddd951b0087c14e951610593653 inherit pub_methods_classuvw_1_1StreamHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f3eeb7d21ca0bbbb7df591fade4e46 inherit pub_methods_classuvw_1_1StreamHandle"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1StreamHandle.html#ae7f3eeb7d21ca0bbbb7df591fade4e46">listen</a> (int backlog=DEFAULT_BACKLOG)</td></tr>
<tr class="memdesc:ae7f3eeb7d21ca0bbbb7df591fade4e46 inherit pub_methods_classuvw_1_1StreamHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts listening for incoming connections.  <a href="classuvw_1_1StreamHandle.html#ae7f3eeb7d21ca0bbbb7df591fade4e46">More...</a><br /></td></tr>
<tr class="separator:ae7f3eeb7d21ca0bbbb7df591fade4e46 inherit pub_methods_classuvw_1_1StreamHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf4576cd5c8c16b63d9a4fe30931b9f inherit pub_methods_classuvw_1_1StreamHandle"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1StreamHandle.html#aebf4576cd5c8c16b63d9a4fe30931b9f">accept</a> (S &amp;ref)</td></tr>
<tr class="memdesc:aebf4576cd5c8c16b63d9a4fe30931b9f inherit pub_methods_classuvw_1_1StreamHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accepts incoming connections.  <a href="classuvw_1_1StreamHandle.html#aebf4576cd5c8c16b63d9a4fe30931b9f">More...</a><br /></td></tr>
<tr class="separator:aebf4576cd5c8c16b63d9a4fe30931b9f inherit pub_methods_classuvw_1_1StreamHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bce95db93fb64ee8b86c41b65a060c8 inherit pub_methods_classuvw_1_1StreamHandle"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1StreamHandle.html#a2bce95db93fb64ee8b86c41b65a060c8">read</a> ()</td></tr>
<tr class="memdesc:a2bce95db93fb64ee8b86c41b65a060c8 inherit pub_methods_classuvw_1_1StreamHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts reading data from an incoming stream.  <a href="classuvw_1_1StreamHandle.html#a2bce95db93fb64ee8b86c41b65a060c8">More...</a><br /></td></tr>
<tr class="separator:a2bce95db93fb64ee8b86c41b65a060c8 inherit pub_methods_classuvw_1_1StreamHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ecf6a0a39f74707b79ff4e8f696bb8 inherit pub_methods_classuvw_1_1StreamHandle"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1StreamHandle.html#aa7ecf6a0a39f74707b79ff4e8f696bb8">stop</a> ()</td></tr>
<tr class="memdesc:aa7ecf6a0a39f74707b79ff4e8f696bb8 inherit pub_methods_classuvw_1_1StreamHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops reading data from the stream.  <a href="classuvw_1_1StreamHandle.html#aa7ecf6a0a39f74707b79ff4e8f696bb8">More...</a><br /></td></tr>
<tr class="separator:aa7ecf6a0a39f74707b79ff4e8f696bb8 inherit pub_methods_classuvw_1_1StreamHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77b0d5368ab31774d5edecf35844705 inherit pub_methods_classuvw_1_1StreamHandle"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1StreamHandle.html#ac77b0d5368ab31774d5edecf35844705">write</a> (std::unique_ptr&lt; char[]&gt; data, unsigned int len)</td></tr>
<tr class="memdesc:ac77b0d5368ab31774d5edecf35844705 inherit pub_methods_classuvw_1_1StreamHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data to the stream.  <a href="classuvw_1_1StreamHandle.html#ac77b0d5368ab31774d5edecf35844705">More...</a><br /></td></tr>
<tr class="separator:ac77b0d5368ab31774d5edecf35844705 inherit pub_methods_classuvw_1_1StreamHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b4f4c4ffb19990bef05c776662f85c inherit pub_methods_classuvw_1_1StreamHandle"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1StreamHandle.html#ad6b4f4c4ffb19990bef05c776662f85c">write</a> (char *data, unsigned int len)</td></tr>
<tr class="memdesc:ad6b4f4c4ffb19990bef05c776662f85c inherit pub_methods_classuvw_1_1StreamHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data to the stream.  <a href="classuvw_1_1StreamHandle.html#ad6b4f4c4ffb19990bef05c776662f85c">More...</a><br /></td></tr>
<tr class="separator:ad6b4f4c4ffb19990bef05c776662f85c inherit pub_methods_classuvw_1_1StreamHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13357c4a56712232c7733f03dc38c67b inherit pub_methods_classuvw_1_1StreamHandle"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1StreamHandle.html#a13357c4a56712232c7733f03dc38c67b">write</a> (S &amp;send, std::unique_ptr&lt; char[]&gt; data, unsigned int len)</td></tr>
<tr class="memdesc:a13357c4a56712232c7733f03dc38c67b inherit pub_methods_classuvw_1_1StreamHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended write function for sending handles over a pipe handle.  <a href="classuvw_1_1StreamHandle.html#a13357c4a56712232c7733f03dc38c67b">More...</a><br /></td></tr>
<tr class="separator:a13357c4a56712232c7733f03dc38c67b inherit pub_methods_classuvw_1_1StreamHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0086873dd2962189c92935bf6855c0c4 inherit pub_methods_classuvw_1_1StreamHandle"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1StreamHandle.html#a0086873dd2962189c92935bf6855c0c4">write</a> (S &amp;send, char *data, unsigned int len)</td></tr>
<tr class="memdesc:a0086873dd2962189c92935bf6855c0c4 inherit pub_methods_classuvw_1_1StreamHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended write function for sending handles over a pipe handle.  <a href="classuvw_1_1StreamHandle.html#a0086873dd2962189c92935bf6855c0c4">More...</a><br /></td></tr>
<tr class="separator:a0086873dd2962189c92935bf6855c0c4 inherit pub_methods_classuvw_1_1StreamHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6f26113dc02442a93b7643842fb415 inherit pub_methods_classuvw_1_1StreamHandle"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1StreamHandle.html#a3f6f26113dc02442a93b7643842fb415">tryWrite</a> (std::unique_ptr&lt; char[]&gt; data, unsigned int len)</td></tr>
<tr class="memdesc:a3f6f26113dc02442a93b7643842fb415 inherit pub_methods_classuvw_1_1StreamHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues a write request if it can be completed immediately.  <a href="classuvw_1_1StreamHandle.html#a3f6f26113dc02442a93b7643842fb415">More...</a><br /></td></tr>
<tr class="separator:a3f6f26113dc02442a93b7643842fb415 inherit pub_methods_classuvw_1_1StreamHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b95a0efb99c96a0427a8f44fd9ddb6 inherit pub_methods_classuvw_1_1StreamHandle"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1StreamHandle.html#a72b95a0efb99c96a0427a8f44fd9ddb6">tryWrite</a> (char *data, unsigned int len)</td></tr>
<tr class="memdesc:a72b95a0efb99c96a0427a8f44fd9ddb6 inherit pub_methods_classuvw_1_1StreamHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues a write request if it can be completed immediately.  <a href="classuvw_1_1StreamHandle.html#a72b95a0efb99c96a0427a8f44fd9ddb6">More...</a><br /></td></tr>
<tr class="separator:a72b95a0efb99c96a0427a8f44fd9ddb6 inherit pub_methods_classuvw_1_1StreamHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91efe7dfb93505779edbf603a6a1c515 inherit pub_methods_classuvw_1_1StreamHandle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1StreamHandle.html#a91efe7dfb93505779edbf603a6a1c515">readable</a> () const noexcept</td></tr>
<tr class="memdesc:a91efe7dfb93505779edbf603a6a1c515 inherit pub_methods_classuvw_1_1StreamHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the stream is readable.  <a href="classuvw_1_1StreamHandle.html#a91efe7dfb93505779edbf603a6a1c515">More...</a><br /></td></tr>
<tr class="separator:a91efe7dfb93505779edbf603a6a1c515 inherit pub_methods_classuvw_1_1StreamHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5918e5e17773fdd8dc078d07809359ea inherit pub_methods_classuvw_1_1StreamHandle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1StreamHandle.html#a5918e5e17773fdd8dc078d07809359ea">writable</a> () const noexcept</td></tr>
<tr class="memdesc:a5918e5e17773fdd8dc078d07809359ea inherit pub_methods_classuvw_1_1StreamHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the stream is writable.  <a href="classuvw_1_1StreamHandle.html#a5918e5e17773fdd8dc078d07809359ea">More...</a><br /></td></tr>
<tr class="separator:a5918e5e17773fdd8dc078d07809359ea inherit pub_methods_classuvw_1_1StreamHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0abb05d8b07840cf0a36c64ec23fc4 inherit pub_methods_classuvw_1_1StreamHandle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1StreamHandle.html#a5f0abb05d8b07840cf0a36c64ec23fc4">blocking</a> (bool enable=false)</td></tr>
<tr class="memdesc:a5f0abb05d8b07840cf0a36c64ec23fc4 inherit pub_methods_classuvw_1_1StreamHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables blocking mode for a stream.  <a href="classuvw_1_1StreamHandle.html#a5f0abb05d8b07840cf0a36c64ec23fc4">More...</a><br /></td></tr>
<tr class="separator:a5f0abb05d8b07840cf0a36c64ec23fc4 inherit pub_methods_classuvw_1_1StreamHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e976a472fd0712ed3a8995450695b9f inherit pub_methods_classuvw_1_1StreamHandle"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1StreamHandle.html#a6e976a472fd0712ed3a8995450695b9f">writeQueueSize</a> () const noexcept</td></tr>
<tr class="memdesc:a6e976a472fd0712ed3a8995450695b9f inherit pub_methods_classuvw_1_1StreamHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the amount of queued bytes waiting to be sent.  <a href="classuvw_1_1StreamHandle.html#a6e976a472fd0712ed3a8995450695b9f">More...</a><br /></td></tr>
<tr class="separator:a6e976a472fd0712ed3a8995450695b9f inherit pub_methods_classuvw_1_1StreamHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classuvw_1_1Handle"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classuvw_1_1Handle')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classuvw_1_1Handle.html">uvw::Handle&lt; TCPHandle, uv_tcp_t &gt;</a></td></tr>
<tr class="memitem:a96162bff13f6bf9a53be386765f01030 inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceuvw.html#aa3ae4a038de60a69b2513a039add1e48">HandleCategory</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#a96162bff13f6bf9a53be386765f01030">category</a> () const noexcept override</td></tr>
<tr class="memdesc:a96162bff13f6bf9a53be386765f01030 inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the category of the handle.  <a href="classuvw_1_1Handle.html#a96162bff13f6bf9a53be386765f01030">More...</a><br /></td></tr>
<tr class="separator:a96162bff13f6bf9a53be386765f01030 inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9056993d6077e8bee8bd77c9b03f2797 inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top">HandleType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#a9056993d6077e8bee8bd77c9b03f2797">type</a> () const noexcept override</td></tr>
<tr class="memdesc:a9056993d6077e8bee8bd77c9b03f2797 inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of the handle.  <a href="classuvw_1_1Handle.html#a9056993d6077e8bee8bd77c9b03f2797">More...</a><br /></td></tr>
<tr class="separator:a9056993d6077e8bee8bd77c9b03f2797 inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18132668364682aae1235f71ff35c903 inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#a18132668364682aae1235f71ff35c903">active</a> () const noexcept override</td></tr>
<tr class="memdesc:a18132668364682aae1235f71ff35c903 inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the handle is active.  <a href="classuvw_1_1Handle.html#a18132668364682aae1235f71ff35c903">More...</a><br /></td></tr>
<tr class="separator:a18132668364682aae1235f71ff35c903 inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b17026726b0999d1dc20c82b84ef0e inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#a94b17026726b0999d1dc20c82b84ef0e">closing</a> () const noexcept override</td></tr>
<tr class="memdesc:a94b17026726b0999d1dc20c82b84ef0e inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a handle is closing or closed.  <a href="classuvw_1_1Handle.html#a94b17026726b0999d1dc20c82b84ef0e">More...</a><br /></td></tr>
<tr class="separator:a94b17026726b0999d1dc20c82b84ef0e inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b7518a56ad891700c40a1578a1d2f1 inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#a83b7518a56ad891700c40a1578a1d2f1">close</a> () noexcept override</td></tr>
<tr class="memdesc:a83b7518a56ad891700c40a1578a1d2f1 inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request handle to be closed.  <a href="classuvw_1_1Handle.html#a83b7518a56ad891700c40a1578a1d2f1">More...</a><br /></td></tr>
<tr class="separator:a83b7518a56ad891700c40a1578a1d2f1 inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd04810b141d54cac4b51c69259f15e9 inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#acd04810b141d54cac4b51c69259f15e9">reference</a> () noexcept override</td></tr>
<tr class="memdesc:acd04810b141d54cac4b51c69259f15e9 inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference the given handle.  <a href="classuvw_1_1Handle.html#acd04810b141d54cac4b51c69259f15e9">More...</a><br /></td></tr>
<tr class="separator:acd04810b141d54cac4b51c69259f15e9 inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4bebc0f0cf639fcf38fd839017857e0 inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#af4bebc0f0cf639fcf38fd839017857e0">unreference</a> () noexcept override</td></tr>
<tr class="memdesc:af4bebc0f0cf639fcf38fd839017857e0 inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unreference the given handle.  <a href="classuvw_1_1Handle.html#af4bebc0f0cf639fcf38fd839017857e0">More...</a><br /></td></tr>
<tr class="separator:af4bebc0f0cf639fcf38fd839017857e0 inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44c23189e6c77b5a3807bb184366fd0 inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#ad44c23189e6c77b5a3807bb184366fd0">referenced</a> () const noexcept override</td></tr>
<tr class="memdesc:ad44c23189e6c77b5a3807bb184366fd0 inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given handle referenced.  <a href="classuvw_1_1Handle.html#ad44c23189e6c77b5a3807bb184366fd0">More...</a><br /></td></tr>
<tr class="separator:ad44c23189e6c77b5a3807bb184366fd0 inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9f911fc627f3feb32fefd67a7d5344 inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#aaf9f911fc627f3feb32fefd67a7d5344">size</a> () const noexcept</td></tr>
<tr class="memdesc:aaf9f911fc627f3feb32fefd67a7d5344 inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the underlying handle type.  <a href="classuvw_1_1Handle.html#aaf9f911fc627f3feb32fefd67a7d5344">More...</a><br /></td></tr>
<tr class="separator:aaf9f911fc627f3feb32fefd67a7d5344 inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381427eccddbc061341642a0647eb5c5 inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#a381427eccddbc061341642a0647eb5c5">sendBufferSize</a> ()</td></tr>
<tr class="memdesc:a381427eccddbc061341642a0647eb5c5 inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the send buffer used for the socket.  <a href="classuvw_1_1Handle.html#a381427eccddbc061341642a0647eb5c5">More...</a><br /></td></tr>
<tr class="separator:a381427eccddbc061341642a0647eb5c5 inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5101de6d8dea3bdd2bca444cde821db inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#ac5101de6d8dea3bdd2bca444cde821db">sendBufferSize</a> (int value)</td></tr>
<tr class="memdesc:ac5101de6d8dea3bdd2bca444cde821db inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the send buffer used for the socket.  <a href="classuvw_1_1Handle.html#ac5101de6d8dea3bdd2bca444cde821db">More...</a><br /></td></tr>
<tr class="separator:ac5101de6d8dea3bdd2bca444cde821db inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf07222a2587ca1eb80aec5a9af892e7 inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#adf07222a2587ca1eb80aec5a9af892e7">recvBufferSize</a> ()</td></tr>
<tr class="memdesc:adf07222a2587ca1eb80aec5a9af892e7 inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the receive buffer used for the socket.  <a href="classuvw_1_1Handle.html#adf07222a2587ca1eb80aec5a9af892e7">More...</a><br /></td></tr>
<tr class="separator:adf07222a2587ca1eb80aec5a9af892e7 inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a549b5f46f62b8474bad8775c6e4ff1a9 inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#a549b5f46f62b8474bad8775c6e4ff1a9">recvBufferSize</a> (int value)</td></tr>
<tr class="memdesc:a549b5f46f62b8474bad8775c6e4ff1a9 inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the receive buffer used for the socket.  <a href="classuvw_1_1Handle.html#a549b5f46f62b8474bad8775c6e4ff1a9">More...</a><br /></td></tr>
<tr class="separator:a549b5f46f62b8474bad8775c6e4ff1a9 inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33f8f753d3a19a0daece518f4a87bee inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceuvw.html#ad4b1016f485b28ad7dfd320a593b152b">OSFileDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#ab33f8f753d3a19a0daece518f4a87bee">fileno</a> () const</td></tr>
<tr class="memdesc:ab33f8f753d3a19a0daece518f4a87bee inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the platform dependent file descriptor equivalent.  <a href="classuvw_1_1Handle.html#ab33f8f753d3a19a0daece518f4a87bee">More...</a><br /></td></tr>
<tr class="separator:ab33f8f753d3a19a0daece518f4a87bee inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classuvw_1_1UnderlyingType"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classuvw_1_1UnderlyingType')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classuvw_1_1UnderlyingType.html">uvw::UnderlyingType&lt; TCPHandle, uv_tcp_t &gt;</a></td></tr>
<tr class="memitem:aab78fbfffb3c03d78aab515e605ecb18 inherit pub_methods_classuvw_1_1UnderlyingType"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuvw_1_1Loop.html">Loop</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1UnderlyingType.html#aab78fbfffb3c03d78aab515e605ecb18">loop</a> () const noexcept</td></tr>
<tr class="memdesc:aab78fbfffb3c03d78aab515e605ecb18 inherit pub_methods_classuvw_1_1UnderlyingType"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the loop from which the resource was originated.  <a href="classuvw_1_1UnderlyingType.html#aab78fbfffb3c03d78aab515e605ecb18">More...</a><br /></td></tr>
<tr class="separator:aab78fbfffb3c03d78aab515e605ecb18 inherit pub_methods_classuvw_1_1UnderlyingType"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2dddf23a571afb113c8b9c5e83f056f inherit pub_methods_classuvw_1_1UnderlyingType"><td class="memItemLeft" align="right" valign="top">const uv_tcp_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1UnderlyingType.html#ab2dddf23a571afb113c8b9c5e83f056f">raw</a> () const noexcept</td></tr>
<tr class="memdesc:ab2dddf23a571afb113c8b9c5e83f056f inherit pub_methods_classuvw_1_1UnderlyingType"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the underlying raw data structure.  <a href="classuvw_1_1UnderlyingType.html#ab2dddf23a571afb113c8b9c5e83f056f">More...</a><br /></td></tr>
<tr class="separator:ab2dddf23a571afb113c8b9c5e83f056f inherit pub_methods_classuvw_1_1UnderlyingType"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ac17a623e508fa410453f8c17e5970 inherit pub_methods_classuvw_1_1UnderlyingType"><td class="memItemLeft" align="right" valign="top">uv_tcp_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1UnderlyingType.html#a78ac17a623e508fa410453f8c17e5970">raw</a> () noexcept</td></tr>
<tr class="memdesc:a78ac17a623e508fa410453f8c17e5970 inherit pub_methods_classuvw_1_1UnderlyingType"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the underlying raw data structure.  <a href="classuvw_1_1UnderlyingType.html#a78ac17a623e508fa410453f8c17e5970">More...</a><br /></td></tr>
<tr class="separator:a78ac17a623e508fa410453f8c17e5970 inherit pub_methods_classuvw_1_1UnderlyingType"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classuvw_1_1Emitter"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classuvw_1_1Emitter')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classuvw_1_1Emitter.html">uvw::Emitter&lt; TCPHandle &gt;</a></td></tr>
<tr class="memitem:af6ba3eecb542efbef8d62ae905d8a8cd inherit pub_methods_classuvw_1_1Emitter"><td class="memItemLeft" align="right" valign="top">Connection&lt; E &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Emitter.html#af6ba3eecb542efbef8d62ae905d8a8cd">on</a> (Listener&lt; E &gt; f)</td></tr>
<tr class="memdesc:af6ba3eecb542efbef8d62ae905d8a8cd inherit pub_methods_classuvw_1_1Emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a long-lived listener with the event emitter.  <a href="classuvw_1_1Emitter.html#af6ba3eecb542efbef8d62ae905d8a8cd">More...</a><br /></td></tr>
<tr class="separator:af6ba3eecb542efbef8d62ae905d8a8cd inherit pub_methods_classuvw_1_1Emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e4ed59b5bb5cdc5ee4b0dd71a38472 inherit pub_methods_classuvw_1_1Emitter"><td class="memItemLeft" align="right" valign="top">Connection&lt; E &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Emitter.html#a79e4ed59b5bb5cdc5ee4b0dd71a38472">once</a> (Listener&lt; E &gt; f)</td></tr>
<tr class="memdesc:a79e4ed59b5bb5cdc5ee4b0dd71a38472 inherit pub_methods_classuvw_1_1Emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a short-lived listener with the event emitter.  <a href="classuvw_1_1Emitter.html#a79e4ed59b5bb5cdc5ee4b0dd71a38472">More...</a><br /></td></tr>
<tr class="separator:a79e4ed59b5bb5cdc5ee4b0dd71a38472 inherit pub_methods_classuvw_1_1Emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c98ab223b4367073d96c51ee3d6a0d1 inherit pub_methods_classuvw_1_1Emitter"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Emitter.html#a4c98ab223b4367073d96c51ee3d6a0d1">erase</a> (Connection&lt; E &gt; conn) noexcept</td></tr>
<tr class="memdesc:a4c98ab223b4367073d96c51ee3d6a0d1 inherit pub_methods_classuvw_1_1Emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects a listener from the event emitter.  <a href="classuvw_1_1Emitter.html#a4c98ab223b4367073d96c51ee3d6a0d1">More...</a><br /></td></tr>
<tr class="separator:a4c98ab223b4367073d96c51ee3d6a0d1 inherit pub_methods_classuvw_1_1Emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d332776a2e35049549a723f35d88912 inherit pub_methods_classuvw_1_1Emitter"><td class="memItemLeft" align="right" valign="top"><a id="a3d332776a2e35049549a723f35d88912"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Emitter.html#a3d332776a2e35049549a723f35d88912">clear</a> () noexcept</td></tr>
<tr class="memdesc:a3d332776a2e35049549a723f35d88912 inherit pub_methods_classuvw_1_1Emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects all the listeners for the given event type. <br /></td></tr>
<tr class="separator:a3d332776a2e35049549a723f35d88912 inherit pub_methods_classuvw_1_1Emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff321dde35550bb40ab90a787b715cf inherit pub_methods_classuvw_1_1Emitter"><td class="memItemLeft" align="right" valign="top"><a id="a6ff321dde35550bb40ab90a787b715cf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Emitter.html#a6ff321dde35550bb40ab90a787b715cf">clear</a> () noexcept</td></tr>
<tr class="memdesc:a6ff321dde35550bb40ab90a787b715cf inherit pub_methods_classuvw_1_1Emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects all the listeners. <br /></td></tr>
<tr class="separator:a6ff321dde35550bb40ab90a787b715cf inherit pub_methods_classuvw_1_1Emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2178cfdcc8b19baa6d7e1f950c7b65c4 inherit pub_methods_classuvw_1_1Emitter"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Emitter.html#a2178cfdcc8b19baa6d7e1f950c7b65c4">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a2178cfdcc8b19baa6d7e1f950c7b65c4 inherit pub_methods_classuvw_1_1Emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there are listeners registered for the specific event.  <a href="classuvw_1_1Emitter.html#a2178cfdcc8b19baa6d7e1f950c7b65c4">More...</a><br /></td></tr>
<tr class="separator:a2178cfdcc8b19baa6d7e1f950c7b65c4 inherit pub_methods_classuvw_1_1Emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15516ea3df907e5e27512d05f64a1cd inherit pub_methods_classuvw_1_1Emitter"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Emitter.html#af15516ea3df907e5e27512d05f64a1cd">empty</a> () const noexcept</td></tr>
<tr class="memdesc:af15516ea3df907e5e27512d05f64a1cd inherit pub_methods_classuvw_1_1Emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there are listeners registered with the event emitter.  <a href="classuvw_1_1Emitter.html#af15516ea3df907e5e27512d05f64a1cd">More...</a><br /></td></tr>
<tr class="separator:af15516ea3df907e5e27512d05f64a1cd inherit pub_methods_classuvw_1_1Emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classuvw_1_1UnderlyingType"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classuvw_1_1UnderlyingType')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classuvw_1_1UnderlyingType.html">uvw::UnderlyingType&lt; TCPHandle, uv_tcp_t &gt;</a></td></tr>
<tr class="memitem:aa711faff7e88895f769f66e8245bda73 inherit pub_static_methods_classuvw_1_1UnderlyingType"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classuvw_1_1TCPHandle.html">TCPHandle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1UnderlyingType.html#aa711faff7e88895f769f66e8245bda73">create</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aa711faff7e88895f769f66e8245bda73 inherit pub_static_methods_classuvw_1_1UnderlyingType"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new resource of the given type.  <a href="classuvw_1_1UnderlyingType.html#aa711faff7e88895f769f66e8245bda73">More...</a><br /></td></tr>
<tr class="separator:aa711faff7e88895f769f66e8245bda73 inherit pub_static_methods_classuvw_1_1UnderlyingType"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classuvw_1_1TCPHandle.html" title="The TCPHandle handle. ">TCPHandle</a> handle. </p>
<p>TCP handles are used to represent both TCP streams and servers.<br />
 By default, <em><a class="el" href="structuvw_1_1IPv4.html" title="The IPv4 tag. ">IPv4</a></em> is used as a template parameter. The handle already supports <em><a class="el" href="structuvw_1_1IPv6.html" title="The IPv6 tag. ">IPv6</a></em> out-of-the-box by using <code><a class="el" href="structuvw_1_1IPv6.html" title="The IPv6 tag. ">uvw::IPv6</a></code>.</p>
<p>To create a <code><a class="el" href="classuvw_1_1TCPHandle.html" title="The TCPHandle handle. ">TCPHandle</a></code> through a <code><a class="el" href="classuvw_1_1Loop.html" title="The Loop class. ">Loop</a></code>, arguments follow:</p>
<ul>
<li>An optional integer value that indicates the flags used to initialize the socket.</li>
</ul>
<p>See the official <a href="http://docs.libuv.org/en/v1.x/tcp.html#c.uv_tcp_init_ex">documentation</a> for further details. </p>

<p class="definition">Definition at line <a class="el" href="tcp_8hpp_source.html#l00045">45</a> of file <a class="el" href="tcp_8hpp_source.html">tcp.hpp</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aca5c2a058049bfd064dd75b55c3ab94e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca5c2a058049bfd064dd75b55c3ab94e">&#9670;&nbsp;</a></span>bind() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void uvw::TCPHandle::bind </td>
          <td>(</td>
          <td class="paramtype">const sockaddr &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classuvw_1_1Flags.html">Flags</a>&lt; Bind &gt;&#160;</td>
          <td class="paramname"><em>opts</em> = <code><a class="el" href="classuvw_1_1Flags.html">Flags</a>&lt;Bind&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binds the handle to an address and port. </p>
<p>A successful call to this function does not guarantee that the call to <code><a class="el" href="classuvw_1_1StreamHandle.html#ae7f3eeb7d21ca0bbbb7df591fade4e46" title="Starts listening for incoming connections. ">listen()</a></code> or <code><a class="el" href="classuvw_1_1TCPHandle.html#ab6d3dc1999fb93d9fd6f7cc59e0946ef" title="Establishes an IPv4 or IPv6 TCP connection. ">connect()</a></code> will work properly.<br />
 <a class="el" href="structuvw_1_1ErrorEvent.html" title="The ErrorEvent event. ">ErrorEvent</a> events can be emitted because of either this function or the ones mentioned above.</p>
<p>Available flags are:</p>
<ul>
<li><code>TCPHandle::Bind::IPV6ONLY</code>: it disables dual-stack support and only <a class="el" href="structuvw_1_1IPv6.html" title="The IPv6 tag. ">IPv6</a> is used.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Initialized <code>sockaddr_in</code> or <code>sockaddr_in6</code> data structure. </td></tr>
    <tr><td class="paramname">opts</td><td>Optional additional flags. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tcp_8hpp_source.html#l00132">132</a> of file <a class="el" href="tcp_8hpp_source.html">tcp.hpp</a>.</p>

</div>
</div>
<a id="a59e9caf8043042ab4de685c4d83004f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e9caf8043042ab4de685c4d83004f3">&#9670;&nbsp;</a></span>bind() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I  = IPv4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void uvw::TCPHandle::bind </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classuvw_1_1Flags.html">Flags</a>&lt; Bind &gt;&#160;</td>
          <td class="paramname"><em>opts</em> = <code><a class="el" href="classuvw_1_1Flags.html">Flags</a>&lt;Bind&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binds the handle to an address and port. </p>
<p>A successful call to this function does not guarantee that the call to <code><a class="el" href="classuvw_1_1StreamHandle.html#ae7f3eeb7d21ca0bbbb7df591fade4e46" title="Starts listening for incoming connections. ">listen()</a></code> or <code><a class="el" href="classuvw_1_1TCPHandle.html#ab6d3dc1999fb93d9fd6f7cc59e0946ef" title="Establishes an IPv4 or IPv6 TCP connection. ">connect()</a></code> will work properly.<br />
 <a class="el" href="structuvw_1_1ErrorEvent.html" title="The ErrorEvent event. ">ErrorEvent</a> events can be emitted because of either this function or the ones mentioned above.</p>
<p>Available flags are:</p>
<ul>
<li><code>TCPHandle::Bind::IPV6ONLY</code>: it disables dual-stack support and only <a class="el" href="structuvw_1_1IPv6.html" title="The IPv6 tag. ">IPv6</a> is used.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip</td><td>The address to which to bind. </td></tr>
    <tr><td class="paramname">port</td><td>The port to which to bind. </td></tr>
    <tr><td class="paramname">opts</td><td>Optional additional flags. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tcp_8hpp_source.html#l00154">154</a> of file <a class="el" href="tcp_8hpp_source.html">tcp.hpp</a>.</p>

</div>
</div>
<a id="a93739ba347c4c095e11005c247c55ec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93739ba347c4c095e11005c247c55ec4">&#9670;&nbsp;</a></span>bind() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I  = IPv4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void uvw::TCPHandle::bind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuvw_1_1Addr.html">Addr</a>&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classuvw_1_1Flags.html">Flags</a>&lt; Bind &gt;&#160;</td>
          <td class="paramname"><em>opts</em> = <code><a class="el" href="classuvw_1_1Flags.html">Flags</a>&lt;Bind&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binds the handle to an address and port. </p>
<p>A successful call to this function does not guarantee that the call to <code><a class="el" href="classuvw_1_1StreamHandle.html#ae7f3eeb7d21ca0bbbb7df591fade4e46" title="Starts listening for incoming connections. ">listen()</a></code> or <code><a class="el" href="classuvw_1_1TCPHandle.html#ab6d3dc1999fb93d9fd6f7cc59e0946ef" title="Establishes an IPv4 or IPv6 TCP connection. ">connect()</a></code> will work properly.<br />
 <a class="el" href="structuvw_1_1ErrorEvent.html" title="The ErrorEvent event. ">ErrorEvent</a> events can be emitted because of either this function or the ones mentioned above.</p>
<p>Available flags are:</p>
<ul>
<li><code>TCPHandle::Bind::IPV6ONLY</code>: it disables dual-stack support and only <a class="el" href="structuvw_1_1IPv6.html" title="The IPv6 tag. ">IPv6</a> is used.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>A valid instance of <a class="el" href="structuvw_1_1Addr.html" title="Address representation. ">Addr</a>. </td></tr>
    <tr><td class="paramname">opts</td><td>Optional additional flags. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tcp_8hpp_source.html#l00177">177</a> of file <a class="el" href="tcp_8hpp_source.html">tcp.hpp</a>.</p>

</div>
</div>
<a id="ab6d3dc1999fb93d9fd6f7cc59e0946ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d3dc1999fb93d9fd6f7cc59e0946ef">&#9670;&nbsp;</a></span>connect() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void uvw::TCPHandle::connect </td>
          <td>(</td>
          <td class="paramtype">const sockaddr &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Establishes an <a class="el" href="structuvw_1_1IPv4.html" title="The IPv4 tag. ">IPv4</a> or <a class="el" href="structuvw_1_1IPv6.html" title="The IPv6 tag. ">IPv6</a> TCP connection. </p>
<p>On Windows if the addr is initialized to point to an unspecified address (<code>0.0.0.0</code> or <code>::</code>) it will be changed to point to localhost. This is done to match the behavior of Linux systems.</p>
<p>A <a class="el" href="structuvw_1_1ConnectEvent.html" title="ConnectEvent event. ">ConnectEvent</a> event is emitted when the connection has been established.<br />
 An <a class="el" href="structuvw_1_1ErrorEvent.html" title="The ErrorEvent event. ">ErrorEvent</a> event is emitted in case of errors during the connection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Initialized <code>sockaddr_in</code> or <code>sockaddr_in6</code> data structure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tcp_8hpp_source.html#l00212">212</a> of file <a class="el" href="tcp_8hpp_source.html">tcp.hpp</a>.</p>

</div>
</div>
<a id="ab249951eb36140348399828d7cb96776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab249951eb36140348399828d7cb96776">&#9670;&nbsp;</a></span>connect() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I  = IPv4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void uvw::TCPHandle::connect </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Establishes an <a class="el" href="structuvw_1_1IPv4.html" title="The IPv4 tag. ">IPv4</a> or <a class="el" href="structuvw_1_1IPv6.html" title="The IPv6 tag. ">IPv6</a> TCP connection. </p>
<p>A <a class="el" href="structuvw_1_1ConnectEvent.html" title="ConnectEvent event. ">ConnectEvent</a> event is emitted when the connection has been established.<br />
 An <a class="el" href="structuvw_1_1ErrorEvent.html" title="The ErrorEvent event. ">ErrorEvent</a> event is emitted in case of errors during the connection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip</td><td>The address to which to bind. </td></tr>
    <tr><td class="paramname">port</td><td>The port to which to bind. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tcp_8hpp_source.html#l00234">234</a> of file <a class="el" href="tcp_8hpp_source.html">tcp.hpp</a>.</p>

</div>
</div>
<a id="ad686cdcb361f426c60788c6f6fa48d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad686cdcb361f426c60788c6f6fa48d44">&#9670;&nbsp;</a></span>connect() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I  = IPv4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void uvw::TCPHandle::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuvw_1_1Addr.html">Addr</a>&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Establishes an <a class="el" href="structuvw_1_1IPv4.html" title="The IPv4 tag. ">IPv4</a> or <a class="el" href="structuvw_1_1IPv6.html" title="The IPv6 tag. ">IPv6</a> TCP connection. </p>
<p>A <a class="el" href="structuvw_1_1ConnectEvent.html" title="ConnectEvent event. ">ConnectEvent</a> event is emitted when the connection has been established.<br />
 An <a class="el" href="structuvw_1_1ErrorEvent.html" title="The ErrorEvent event. ">ErrorEvent</a> event is emitted in case of errors during the connection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>A valid instance of <a class="el" href="structuvw_1_1Addr.html" title="Address representation. ">Addr</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tcp_8hpp_source.html#l00250">250</a> of file <a class="el" href="tcp_8hpp_source.html">tcp.hpp</a>.</p>

</div>
</div>
<a id="a1e4b789c4071720ba05fd89adfcb4e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4b789c4071720ba05fd89adfcb4e41">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool uvw::TCPHandle::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the handle. No socket is created as of yet. </p>
<dl class="section return"><dt>Returns</dt><dd>True in case of success, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tcp_8hpp_source.html#l00060">60</a> of file <a class="el" href="tcp_8hpp_source.html">tcp.hpp</a>.</p>

</div>
</div>
<a id="a37b628dd0ccddf127860e3c7ee5b3c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37b628dd0ccddf127860e3c7ee5b3c18">&#9670;&nbsp;</a></span>keepAlive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool uvw::TCPHandle::keepAlive </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Time&#160;</td>
          <td class="paramname"><em>time</em> = <code>Time{0}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables/Disables TCP keep-alive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>True to enable it, false otherwise. </td></tr>
    <tr><td class="paramname">time</td><td>Initial delay in seconds (use <code>std::chrono::duration&lt;unsigned int&gt;</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True in case of success, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tcp_8hpp_source.html#l00094">94</a> of file <a class="el" href="tcp_8hpp_source.html">tcp.hpp</a>.</p>

</div>
</div>
<a id="a3837999138b3450036f3631b009b2c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3837999138b3450036f3631b009b2c71">&#9670;&nbsp;</a></span>noDelay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool uvw::TCPHandle::noDelay </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables/Disables Nagleâ€™s algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>True to enable it, false otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True in case of success, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tcp_8hpp_source.html#l00083">83</a> of file <a class="el" href="tcp_8hpp_source.html">tcp.hpp</a>.</p>

</div>
</div>
<a id="a32fc3f653d1d920fffeae485b3237281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32fc3f653d1d920fffeae485b3237281">&#9670;&nbsp;</a></span>open()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void uvw::TCPHandle::open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceuvw.html#a2df38e5bba10fc959ef37074cf580097">OSSocketHandle</a>&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens an existing file descriptor or SOCKET as a TCP handle. </p>
<p>The passed file descriptor or SOCKET is not checked for its type, but itâ€™s required that it represents a valid stream socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>A valid socket handle (either a file descriptor or a SOCKET). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tcp_8hpp_source.html#l00074">74</a> of file <a class="el" href="tcp_8hpp_source.html">tcp.hpp</a>.</p>

</div>
</div>
<a id="a495c52e8e0b5210d21c0cdbdc2cf1579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a495c52e8e0b5210d21c0cdbdc2cf1579">&#9670;&nbsp;</a></span>peer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I  = IPv4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structuvw_1_1Addr.html">Addr</a> uvw::TCPHandle::peer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the address of the peer connected to the handle. </p>
<dl class="section return"><dt>Returns</dt><dd>A valid instance of <a class="el" href="structuvw_1_1Addr.html" title="Address representation. ">Addr</a>, an empty one in case of errors. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tcp_8hpp_source.html#l00195">195</a> of file <a class="el" href="tcp_8hpp_source.html">tcp.hpp</a>.</p>

</div>
</div>
<a id="a5a6615582d687d7405b4b6930598ab5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a6615582d687d7405b4b6930598ab5a">&#9670;&nbsp;</a></span>simultaneousAccepts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool uvw::TCPHandle::simultaneousAccepts </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables/Disables simultaneous asynchronous accept requests. </p>
<p>Enables/Disables simultaneous asynchronous accept requests that are queued by the operating system when listening for new TCP connections.<br />
 This setting is used to tune a TCP server for the desired performance. Having simultaneous accepts can significantly improve the rate of accepting connections (which is why it is enabled by default) but may lead to uneven load distribution in multi-process setups.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>True to enable it, false otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True in case of success, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tcp_8hpp_source.html#l00112">112</a> of file <a class="el" href="tcp_8hpp_source.html">tcp.hpp</a>.</p>

</div>
</div>
<a id="a2c1f12926ca9e108749b33cee9a6bcdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c1f12926ca9e108749b33cee9a6bcdf">&#9670;&nbsp;</a></span>sock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I  = IPv4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structuvw_1_1Addr.html">Addr</a> uvw::TCPHandle::sock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the current address to which the handle is bound. </p>
<dl class="section return"><dt>Returns</dt><dd>A valid instance of <a class="el" href="structuvw_1_1Addr.html" title="Address representation. ">Addr</a>, an empty one in case of errors. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tcp_8hpp_source.html#l00186">186</a> of file <a class="el" href="tcp_8hpp_source.html">tcp.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/uvw/<a class="el" href="tcp_8hpp_source.html">tcp.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
