<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>uvw: uvw::StreamHandle&lt; T, U &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">uvw
   &#160;<span id="projectnumber">1.11.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceuvw.html">uvw</a></li><li class="navelem"><a class="el" href="classuvw_1_1StreamHandle.html">StreamHandle</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classuvw_1_1StreamHandle-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">uvw::StreamHandle&lt; T, U &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classuvw_1_1StreamHandle.html" title="The StreamHandle handle. ">StreamHandle</a> handle.  
 <a href="classuvw_1_1StreamHandle.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="stream_8hpp_source.html">stream.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for uvw::StreamHandle&lt; T, U &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classuvw_1_1StreamHandle__inherit__graph.png" border="0" usemap="#uvw_1_1StreamHandle_3_01T_00_01U_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="uvw_1_1StreamHandle_3_01T_00_01U_01_4_inherit__map" id="uvw_1_1StreamHandle_3_01T_00_01U_01_4_inherit__map">
<area shape="rect" id="node2" href="classuvw_1_1Handle.html" title="Handle base class. " alt="" coords="78,169,223,196"/>
<area shape="rect" id="node3" href="structuvw_1_1BaseHandle.html" title="Untyped handle class. " alt="" coords="5,95,131,121"/>
<area shape="rect" id="node4" href="classuvw_1_1Resource.html" title="Common class for almost all the resources available in uvw. " alt="" coords="155,95,315,121"/>
<area shape="rect" id="node5" href="classuvw_1_1UnderlyingType.html" title="Wrapper class for underlying types. " alt="" coords="81,5,226,47"/>
<area shape="rect" id="node6" href="classuvw_1_1Emitter.html" title="Event emitter base class. " alt="" coords="251,13,379,39"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for uvw::StreamHandle&lt; T, U &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classuvw_1_1StreamHandle__coll__graph.png" border="0" usemap="#uvw_1_1StreamHandle_3_01T_00_01U_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="uvw_1_1StreamHandle_3_01T_00_01U_01_4_coll__map" id="uvw_1_1StreamHandle_3_01T_00_01U_01_4_coll__map">
<area shape="rect" id="node2" href="classuvw_1_1Handle.html" title="Handle base class. " alt="" coords="78,169,223,196"/>
<area shape="rect" id="node3" href="structuvw_1_1BaseHandle.html" title="Untyped handle class. " alt="" coords="5,95,131,121"/>
<area shape="rect" id="node4" href="classuvw_1_1Resource.html" title="Common class for almost all the resources available in uvw. " alt="" coords="155,95,315,121"/>
<area shape="rect" id="node5" href="classuvw_1_1UnderlyingType.html" title="Wrapper class for underlying types. " alt="" coords="81,5,226,47"/>
<area shape="rect" id="node6" href="classuvw_1_1Emitter.html" title="Event emitter base class. " alt="" coords="251,13,379,39"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3c1a1ddd951b0087c14e951610593653"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1StreamHandle.html#a3c1a1ddd951b0087c14e951610593653">shutdown</a> ()</td></tr>
<tr class="memdesc:a3c1a1ddd951b0087c14e951610593653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shutdowns the outgoing (write) side of a duplex stream.  <a href="#a3c1a1ddd951b0087c14e951610593653">More...</a><br /></td></tr>
<tr class="separator:a3c1a1ddd951b0087c14e951610593653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f3eeb7d21ca0bbbb7df591fade4e46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1StreamHandle.html#ae7f3eeb7d21ca0bbbb7df591fade4e46">listen</a> (int backlog=DEFAULT_BACKLOG)</td></tr>
<tr class="memdesc:ae7f3eeb7d21ca0bbbb7df591fade4e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts listening for incoming connections.  <a href="#ae7f3eeb7d21ca0bbbb7df591fade4e46">More...</a><br /></td></tr>
<tr class="separator:ae7f3eeb7d21ca0bbbb7df591fade4e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf4576cd5c8c16b63d9a4fe30931b9f"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:aebf4576cd5c8c16b63d9a4fe30931b9f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1StreamHandle.html#aebf4576cd5c8c16b63d9a4fe30931b9f">accept</a> (S &amp;ref)</td></tr>
<tr class="memdesc:aebf4576cd5c8c16b63d9a4fe30931b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accepts incoming connections.  <a href="#aebf4576cd5c8c16b63d9a4fe30931b9f">More...</a><br /></td></tr>
<tr class="separator:aebf4576cd5c8c16b63d9a4fe30931b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bce95db93fb64ee8b86c41b65a060c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1StreamHandle.html#a2bce95db93fb64ee8b86c41b65a060c8">read</a> ()</td></tr>
<tr class="memdesc:a2bce95db93fb64ee8b86c41b65a060c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts reading data from an incoming stream.  <a href="#a2bce95db93fb64ee8b86c41b65a060c8">More...</a><br /></td></tr>
<tr class="separator:a2bce95db93fb64ee8b86c41b65a060c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ecf6a0a39f74707b79ff4e8f696bb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1StreamHandle.html#aa7ecf6a0a39f74707b79ff4e8f696bb8">stop</a> ()</td></tr>
<tr class="memdesc:aa7ecf6a0a39f74707b79ff4e8f696bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops reading data from the stream.  <a href="#aa7ecf6a0a39f74707b79ff4e8f696bb8">More...</a><br /></td></tr>
<tr class="separator:aa7ecf6a0a39f74707b79ff4e8f696bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77b0d5368ab31774d5edecf35844705"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1StreamHandle.html#ac77b0d5368ab31774d5edecf35844705">write</a> (std::unique_ptr&lt; char[]&gt; data, unsigned int len)</td></tr>
<tr class="memdesc:ac77b0d5368ab31774d5edecf35844705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data to the stream.  <a href="#ac77b0d5368ab31774d5edecf35844705">More...</a><br /></td></tr>
<tr class="separator:ac77b0d5368ab31774d5edecf35844705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b4f4c4ffb19990bef05c776662f85c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1StreamHandle.html#ad6b4f4c4ffb19990bef05c776662f85c">write</a> (char *data, unsigned int len)</td></tr>
<tr class="memdesc:ad6b4f4c4ffb19990bef05c776662f85c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data to the stream.  <a href="#ad6b4f4c4ffb19990bef05c776662f85c">More...</a><br /></td></tr>
<tr class="separator:ad6b4f4c4ffb19990bef05c776662f85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13357c4a56712232c7733f03dc38c67b"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:a13357c4a56712232c7733f03dc38c67b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1StreamHandle.html#a13357c4a56712232c7733f03dc38c67b">write</a> (S &amp;send, std::unique_ptr&lt; char[]&gt; data, unsigned int len)</td></tr>
<tr class="memdesc:a13357c4a56712232c7733f03dc38c67b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended write function for sending handles over a pipe handle.  <a href="#a13357c4a56712232c7733f03dc38c67b">More...</a><br /></td></tr>
<tr class="separator:a13357c4a56712232c7733f03dc38c67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0086873dd2962189c92935bf6855c0c4"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:a0086873dd2962189c92935bf6855c0c4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1StreamHandle.html#a0086873dd2962189c92935bf6855c0c4">write</a> (S &amp;send, char *data, unsigned int len)</td></tr>
<tr class="memdesc:a0086873dd2962189c92935bf6855c0c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended write function for sending handles over a pipe handle.  <a href="#a0086873dd2962189c92935bf6855c0c4">More...</a><br /></td></tr>
<tr class="separator:a0086873dd2962189c92935bf6855c0c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6f26113dc02442a93b7643842fb415"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1StreamHandle.html#a3f6f26113dc02442a93b7643842fb415">tryWrite</a> (std::unique_ptr&lt; char[]&gt; data, unsigned int len)</td></tr>
<tr class="memdesc:a3f6f26113dc02442a93b7643842fb415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues a write request if it can be completed immediately.  <a href="#a3f6f26113dc02442a93b7643842fb415">More...</a><br /></td></tr>
<tr class="separator:a3f6f26113dc02442a93b7643842fb415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b95a0efb99c96a0427a8f44fd9ddb6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1StreamHandle.html#a72b95a0efb99c96a0427a8f44fd9ddb6">tryWrite</a> (char *data, unsigned int len)</td></tr>
<tr class="memdesc:a72b95a0efb99c96a0427a8f44fd9ddb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues a write request if it can be completed immediately.  <a href="#a72b95a0efb99c96a0427a8f44fd9ddb6">More...</a><br /></td></tr>
<tr class="separator:a72b95a0efb99c96a0427a8f44fd9ddb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91efe7dfb93505779edbf603a6a1c515"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1StreamHandle.html#a91efe7dfb93505779edbf603a6a1c515">readable</a> () const noexcept</td></tr>
<tr class="memdesc:a91efe7dfb93505779edbf603a6a1c515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the stream is readable.  <a href="#a91efe7dfb93505779edbf603a6a1c515">More...</a><br /></td></tr>
<tr class="separator:a91efe7dfb93505779edbf603a6a1c515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5918e5e17773fdd8dc078d07809359ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1StreamHandle.html#a5918e5e17773fdd8dc078d07809359ea">writable</a> () const noexcept</td></tr>
<tr class="memdesc:a5918e5e17773fdd8dc078d07809359ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the stream is writable.  <a href="#a5918e5e17773fdd8dc078d07809359ea">More...</a><br /></td></tr>
<tr class="separator:a5918e5e17773fdd8dc078d07809359ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0abb05d8b07840cf0a36c64ec23fc4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1StreamHandle.html#a5f0abb05d8b07840cf0a36c64ec23fc4">blocking</a> (bool enable=false)</td></tr>
<tr class="memdesc:a5f0abb05d8b07840cf0a36c64ec23fc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables blocking mode for a stream.  <a href="#a5f0abb05d8b07840cf0a36c64ec23fc4">More...</a><br /></td></tr>
<tr class="separator:a5f0abb05d8b07840cf0a36c64ec23fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e976a472fd0712ed3a8995450695b9f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1StreamHandle.html#a6e976a472fd0712ed3a8995450695b9f">writeQueueSize</a> () const noexcept</td></tr>
<tr class="memdesc:a6e976a472fd0712ed3a8995450695b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the amount of queued bytes waiting to be sent.  <a href="#a6e976a472fd0712ed3a8995450695b9f">More...</a><br /></td></tr>
<tr class="separator:a6e976a472fd0712ed3a8995450695b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classuvw_1_1Handle"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classuvw_1_1Handle')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classuvw_1_1Handle.html">uvw::Handle&lt; T, U &gt;</a></td></tr>
<tr class="memitem:a96162bff13f6bf9a53be386765f01030 inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceuvw.html#aa3ae4a038de60a69b2513a039add1e48">HandleCategory</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#a96162bff13f6bf9a53be386765f01030">category</a> () const noexcept override</td></tr>
<tr class="memdesc:a96162bff13f6bf9a53be386765f01030 inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the category of the handle.  <a href="classuvw_1_1Handle.html#a96162bff13f6bf9a53be386765f01030">More...</a><br /></td></tr>
<tr class="separator:a96162bff13f6bf9a53be386765f01030 inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9056993d6077e8bee8bd77c9b03f2797 inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceuvw.html#ad8b4c4aaf16bbe0b08218b42fbf32f0e">HandleType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#a9056993d6077e8bee8bd77c9b03f2797">type</a> () const noexcept override</td></tr>
<tr class="memdesc:a9056993d6077e8bee8bd77c9b03f2797 inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of the handle.  <a href="classuvw_1_1Handle.html#a9056993d6077e8bee8bd77c9b03f2797">More...</a><br /></td></tr>
<tr class="separator:a9056993d6077e8bee8bd77c9b03f2797 inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18132668364682aae1235f71ff35c903 inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#a18132668364682aae1235f71ff35c903">active</a> () const noexcept override</td></tr>
<tr class="memdesc:a18132668364682aae1235f71ff35c903 inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the handle is active.  <a href="classuvw_1_1Handle.html#a18132668364682aae1235f71ff35c903">More...</a><br /></td></tr>
<tr class="separator:a18132668364682aae1235f71ff35c903 inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b17026726b0999d1dc20c82b84ef0e inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#a94b17026726b0999d1dc20c82b84ef0e">closing</a> () const noexcept override</td></tr>
<tr class="memdesc:a94b17026726b0999d1dc20c82b84ef0e inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a handle is closing or closed.  <a href="classuvw_1_1Handle.html#a94b17026726b0999d1dc20c82b84ef0e">More...</a><br /></td></tr>
<tr class="separator:a94b17026726b0999d1dc20c82b84ef0e inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b7518a56ad891700c40a1578a1d2f1 inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#a83b7518a56ad891700c40a1578a1d2f1">close</a> () noexcept override</td></tr>
<tr class="memdesc:a83b7518a56ad891700c40a1578a1d2f1 inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request handle to be closed.  <a href="classuvw_1_1Handle.html#a83b7518a56ad891700c40a1578a1d2f1">More...</a><br /></td></tr>
<tr class="separator:a83b7518a56ad891700c40a1578a1d2f1 inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd04810b141d54cac4b51c69259f15e9 inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#acd04810b141d54cac4b51c69259f15e9">reference</a> () noexcept override</td></tr>
<tr class="memdesc:acd04810b141d54cac4b51c69259f15e9 inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference the given handle.  <a href="classuvw_1_1Handle.html#acd04810b141d54cac4b51c69259f15e9">More...</a><br /></td></tr>
<tr class="separator:acd04810b141d54cac4b51c69259f15e9 inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4bebc0f0cf639fcf38fd839017857e0 inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#af4bebc0f0cf639fcf38fd839017857e0">unreference</a> () noexcept override</td></tr>
<tr class="memdesc:af4bebc0f0cf639fcf38fd839017857e0 inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unreference the given handle.  <a href="classuvw_1_1Handle.html#af4bebc0f0cf639fcf38fd839017857e0">More...</a><br /></td></tr>
<tr class="separator:af4bebc0f0cf639fcf38fd839017857e0 inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44c23189e6c77b5a3807bb184366fd0 inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#ad44c23189e6c77b5a3807bb184366fd0">referenced</a> () const noexcept override</td></tr>
<tr class="memdesc:ad44c23189e6c77b5a3807bb184366fd0 inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given handle referenced.  <a href="classuvw_1_1Handle.html#ad44c23189e6c77b5a3807bb184366fd0">More...</a><br /></td></tr>
<tr class="separator:ad44c23189e6c77b5a3807bb184366fd0 inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9f911fc627f3feb32fefd67a7d5344 inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#aaf9f911fc627f3feb32fefd67a7d5344">size</a> () const noexcept</td></tr>
<tr class="memdesc:aaf9f911fc627f3feb32fefd67a7d5344 inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the underlying handle type.  <a href="classuvw_1_1Handle.html#aaf9f911fc627f3feb32fefd67a7d5344">More...</a><br /></td></tr>
<tr class="separator:aaf9f911fc627f3feb32fefd67a7d5344 inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381427eccddbc061341642a0647eb5c5 inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#a381427eccddbc061341642a0647eb5c5">sendBufferSize</a> ()</td></tr>
<tr class="memdesc:a381427eccddbc061341642a0647eb5c5 inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the send buffer used for the socket.  <a href="classuvw_1_1Handle.html#a381427eccddbc061341642a0647eb5c5">More...</a><br /></td></tr>
<tr class="separator:a381427eccddbc061341642a0647eb5c5 inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5101de6d8dea3bdd2bca444cde821db inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#ac5101de6d8dea3bdd2bca444cde821db">sendBufferSize</a> (int value)</td></tr>
<tr class="memdesc:ac5101de6d8dea3bdd2bca444cde821db inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the send buffer used for the socket.  <a href="classuvw_1_1Handle.html#ac5101de6d8dea3bdd2bca444cde821db">More...</a><br /></td></tr>
<tr class="separator:ac5101de6d8dea3bdd2bca444cde821db inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf07222a2587ca1eb80aec5a9af892e7 inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#adf07222a2587ca1eb80aec5a9af892e7">recvBufferSize</a> ()</td></tr>
<tr class="memdesc:adf07222a2587ca1eb80aec5a9af892e7 inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the receive buffer used for the socket.  <a href="classuvw_1_1Handle.html#adf07222a2587ca1eb80aec5a9af892e7">More...</a><br /></td></tr>
<tr class="separator:adf07222a2587ca1eb80aec5a9af892e7 inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a549b5f46f62b8474bad8775c6e4ff1a9 inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#a549b5f46f62b8474bad8775c6e4ff1a9">recvBufferSize</a> (int value)</td></tr>
<tr class="memdesc:a549b5f46f62b8474bad8775c6e4ff1a9 inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the receive buffer used for the socket.  <a href="classuvw_1_1Handle.html#a549b5f46f62b8474bad8775c6e4ff1a9">More...</a><br /></td></tr>
<tr class="separator:a549b5f46f62b8474bad8775c6e4ff1a9 inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33f8f753d3a19a0daece518f4a87bee inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceuvw.html#ad4b1016f485b28ad7dfd320a593b152b">OSFileDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#ab33f8f753d3a19a0daece518f4a87bee">fileno</a> () const</td></tr>
<tr class="memdesc:ab33f8f753d3a19a0daece518f4a87bee inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the platform dependent file descriptor equivalent.  <a href="classuvw_1_1Handle.html#ab33f8f753d3a19a0daece518f4a87bee">More...</a><br /></td></tr>
<tr class="separator:ab33f8f753d3a19a0daece518f4a87bee inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classuvw_1_1UnderlyingType"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classuvw_1_1UnderlyingType')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classuvw_1_1UnderlyingType.html">uvw::UnderlyingType&lt; T, U &gt;</a></td></tr>
<tr class="memitem:aab78fbfffb3c03d78aab515e605ecb18 inherit pub_methods_classuvw_1_1UnderlyingType"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuvw_1_1Loop.html">Loop</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1UnderlyingType.html#aab78fbfffb3c03d78aab515e605ecb18">loop</a> () const noexcept</td></tr>
<tr class="memdesc:aab78fbfffb3c03d78aab515e605ecb18 inherit pub_methods_classuvw_1_1UnderlyingType"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the loop from which the resource was originated.  <a href="classuvw_1_1UnderlyingType.html#aab78fbfffb3c03d78aab515e605ecb18">More...</a><br /></td></tr>
<tr class="separator:aab78fbfffb3c03d78aab515e605ecb18 inherit pub_methods_classuvw_1_1UnderlyingType"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2dddf23a571afb113c8b9c5e83f056f inherit pub_methods_classuvw_1_1UnderlyingType"><td class="memItemLeft" align="right" valign="top">const U *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1UnderlyingType.html#ab2dddf23a571afb113c8b9c5e83f056f">raw</a> () const noexcept</td></tr>
<tr class="memdesc:ab2dddf23a571afb113c8b9c5e83f056f inherit pub_methods_classuvw_1_1UnderlyingType"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the underlying raw data structure.  <a href="classuvw_1_1UnderlyingType.html#ab2dddf23a571afb113c8b9c5e83f056f">More...</a><br /></td></tr>
<tr class="separator:ab2dddf23a571afb113c8b9c5e83f056f inherit pub_methods_classuvw_1_1UnderlyingType"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ac17a623e508fa410453f8c17e5970 inherit pub_methods_classuvw_1_1UnderlyingType"><td class="memItemLeft" align="right" valign="top">U *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1UnderlyingType.html#a78ac17a623e508fa410453f8c17e5970">raw</a> () noexcept</td></tr>
<tr class="memdesc:a78ac17a623e508fa410453f8c17e5970 inherit pub_methods_classuvw_1_1UnderlyingType"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the underlying raw data structure.  <a href="classuvw_1_1UnderlyingType.html#a78ac17a623e508fa410453f8c17e5970">More...</a><br /></td></tr>
<tr class="separator:a78ac17a623e508fa410453f8c17e5970 inherit pub_methods_classuvw_1_1UnderlyingType"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classuvw_1_1Emitter"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classuvw_1_1Emitter')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classuvw_1_1Emitter.html">uvw::Emitter&lt; T &gt;</a></td></tr>
<tr class="memitem:af6ba3eecb542efbef8d62ae905d8a8cd inherit pub_methods_classuvw_1_1Emitter"><td class="memTemplParams" colspan="2">template&lt;typename E &gt; </td></tr>
<tr class="memitem:af6ba3eecb542efbef8d62ae905d8a8cd inherit pub_methods_classuvw_1_1Emitter"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structuvw_1_1Emitter_1_1Connection.html">Connection</a>&lt; E &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1Emitter.html#af6ba3eecb542efbef8d62ae905d8a8cd">on</a> (Listener&lt; E &gt; f)</td></tr>
<tr class="memdesc:af6ba3eecb542efbef8d62ae905d8a8cd inherit pub_methods_classuvw_1_1Emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a long-lived listener with the event emitter.  <a href="classuvw_1_1Emitter.html#af6ba3eecb542efbef8d62ae905d8a8cd">More...</a><br /></td></tr>
<tr class="separator:af6ba3eecb542efbef8d62ae905d8a8cd inherit pub_methods_classuvw_1_1Emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e4ed59b5bb5cdc5ee4b0dd71a38472 inherit pub_methods_classuvw_1_1Emitter"><td class="memTemplParams" colspan="2">template&lt;typename E &gt; </td></tr>
<tr class="memitem:a79e4ed59b5bb5cdc5ee4b0dd71a38472 inherit pub_methods_classuvw_1_1Emitter"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structuvw_1_1Emitter_1_1Connection.html">Connection</a>&lt; E &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1Emitter.html#a79e4ed59b5bb5cdc5ee4b0dd71a38472">once</a> (Listener&lt; E &gt; f)</td></tr>
<tr class="memdesc:a79e4ed59b5bb5cdc5ee4b0dd71a38472 inherit pub_methods_classuvw_1_1Emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a short-lived listener with the event emitter.  <a href="classuvw_1_1Emitter.html#a79e4ed59b5bb5cdc5ee4b0dd71a38472">More...</a><br /></td></tr>
<tr class="separator:a79e4ed59b5bb5cdc5ee4b0dd71a38472 inherit pub_methods_classuvw_1_1Emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c98ab223b4367073d96c51ee3d6a0d1 inherit pub_methods_classuvw_1_1Emitter"><td class="memTemplParams" colspan="2">template&lt;typename E &gt; </td></tr>
<tr class="memitem:a4c98ab223b4367073d96c51ee3d6a0d1 inherit pub_methods_classuvw_1_1Emitter"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1Emitter.html#a4c98ab223b4367073d96c51ee3d6a0d1">erase</a> (<a class="el" href="structuvw_1_1Emitter_1_1Connection.html">Connection</a>&lt; E &gt; conn) noexcept</td></tr>
<tr class="memdesc:a4c98ab223b4367073d96c51ee3d6a0d1 inherit pub_methods_classuvw_1_1Emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects a listener from the event emitter.  <a href="classuvw_1_1Emitter.html#a4c98ab223b4367073d96c51ee3d6a0d1">More...</a><br /></td></tr>
<tr class="separator:a4c98ab223b4367073d96c51ee3d6a0d1 inherit pub_methods_classuvw_1_1Emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d332776a2e35049549a723f35d88912 inherit pub_methods_classuvw_1_1Emitter"><td class="memTemplParams" colspan="2"><a id="a3d332776a2e35049549a723f35d88912"></a>
template&lt;typename E &gt; </td></tr>
<tr class="memitem:a3d332776a2e35049549a723f35d88912 inherit pub_methods_classuvw_1_1Emitter"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1Emitter.html#a3d332776a2e35049549a723f35d88912">clear</a> () noexcept</td></tr>
<tr class="memdesc:a3d332776a2e35049549a723f35d88912 inherit pub_methods_classuvw_1_1Emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects all the listeners for the given event type. <br /></td></tr>
<tr class="separator:a3d332776a2e35049549a723f35d88912 inherit pub_methods_classuvw_1_1Emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff321dde35550bb40ab90a787b715cf inherit pub_methods_classuvw_1_1Emitter"><td class="memItemLeft" align="right" valign="top"><a id="a6ff321dde35550bb40ab90a787b715cf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Emitter.html#a6ff321dde35550bb40ab90a787b715cf">clear</a> () noexcept</td></tr>
<tr class="memdesc:a6ff321dde35550bb40ab90a787b715cf inherit pub_methods_classuvw_1_1Emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects all the listeners. <br /></td></tr>
<tr class="separator:a6ff321dde35550bb40ab90a787b715cf inherit pub_methods_classuvw_1_1Emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2178cfdcc8b19baa6d7e1f950c7b65c4 inherit pub_methods_classuvw_1_1Emitter"><td class="memTemplParams" colspan="2">template&lt;typename E &gt; </td></tr>
<tr class="memitem:a2178cfdcc8b19baa6d7e1f950c7b65c4 inherit pub_methods_classuvw_1_1Emitter"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1Emitter.html#a2178cfdcc8b19baa6d7e1f950c7b65c4">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a2178cfdcc8b19baa6d7e1f950c7b65c4 inherit pub_methods_classuvw_1_1Emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there are listeners registered for the specific event.  <a href="classuvw_1_1Emitter.html#a2178cfdcc8b19baa6d7e1f950c7b65c4">More...</a><br /></td></tr>
<tr class="separator:a2178cfdcc8b19baa6d7e1f950c7b65c4 inherit pub_methods_classuvw_1_1Emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15516ea3df907e5e27512d05f64a1cd inherit pub_methods_classuvw_1_1Emitter"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Emitter.html#af15516ea3df907e5e27512d05f64a1cd">empty</a> () const noexcept</td></tr>
<tr class="memdesc:af15516ea3df907e5e27512d05f64a1cd inherit pub_methods_classuvw_1_1Emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there are listeners registered with the event emitter.  <a href="classuvw_1_1Emitter.html#af15516ea3df907e5e27512d05f64a1cd">More...</a><br /></td></tr>
<tr class="separator:af15516ea3df907e5e27512d05f64a1cd inherit pub_methods_classuvw_1_1Emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classuvw_1_1UnderlyingType"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classuvw_1_1UnderlyingType')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classuvw_1_1UnderlyingType.html">uvw::UnderlyingType&lt; T, U &gt;</a></td></tr>
<tr class="memitem:aa711faff7e88895f769f66e8245bda73 inherit pub_static_methods_classuvw_1_1UnderlyingType"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aa711faff7e88895f769f66e8245bda73 inherit pub_static_methods_classuvw_1_1UnderlyingType"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1UnderlyingType.html#aa711faff7e88895f769f66e8245bda73">create</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aa711faff7e88895f769f66e8245bda73 inherit pub_static_methods_classuvw_1_1UnderlyingType"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new resource of the given type.  <a href="classuvw_1_1UnderlyingType.html#aa711faff7e88895f769f66e8245bda73">More...</a><br /></td></tr>
<tr class="separator:aa711faff7e88895f769f66e8245bda73 inherit pub_static_methods_classuvw_1_1UnderlyingType"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename U&gt;<br />
class uvw::StreamHandle&lt; T, U &gt;</h3>

<p>The <a class="el" href="classuvw_1_1StreamHandle.html" title="The StreamHandle handle. ">StreamHandle</a> handle. </p>
<p>Stream handles provide an abstraction of a duplex communication channel. <a class="el" href="classuvw_1_1StreamHandle.html" title="The StreamHandle handle. ">StreamHandle</a> is an intermediate type, <code>uvw</code> provides three stream implementations: <a class="el" href="classuvw_1_1TcpHandle.html" title="The TcpHandle handle. ">TcpHandle</a>, <a class="el" href="classuvw_1_1PipeHandle.html" title="The PipeHandle handle. ">PipeHandle</a> and <a class="el" href="classuvw_1_1TTYHandle.html" title="The TTYHandle handle. ">TTYHandle</a>. </p>

<p class="definition">Definition at line <a class="el" href="stream_8hpp_source.html#l00130">130</a> of file <a class="el" href="stream_8hpp_source.html">stream.hpp</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aebf4576cd5c8c16b63d9a4fe30931b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf4576cd5c8c16b63d9a4fe30931b9f">&#9670;&nbsp;</a></span>accept()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U&gt; </div>
<div class="memtemplate">
template&lt;typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuvw_1_1StreamHandle.html">uvw::StreamHandle</a>&lt; T, U &gt;::accept </td>
          <td>(</td>
          <td class="paramtype">S &amp;&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accepts incoming connections. </p>
<p>This call is used in conjunction with <code><a class="el" href="classuvw_1_1StreamHandle.html#ae7f3eeb7d21ca0bbbb7df591fade4e46" title="Starts listening for incoming connections. ">listen()</a></code> to accept incoming connections. Call this function after receiving a <a class="el" href="structuvw_1_1ListenEvent.html" title="ListenEvent event. ">ListenEvent</a> event to accept the connection. Before calling this function, the submitted handle must be initialized.<br />
 An <a class="el" href="structuvw_1_1ErrorEvent.html" title="The ErrorEvent event. ">ErrorEvent</a> event will be emitted in case of errors.</p>
<p>When the <a class="el" href="structuvw_1_1ListenEvent.html" title="ListenEvent event. ">ListenEvent</a> event is emitted it is guaranteed that this function will complete successfully the first time. If you attempt to use it more than once, it may fail.<br />
 It is suggested to only call this function once per <a class="el" href="structuvw_1_1ListenEvent.html" title="ListenEvent event. ">ListenEvent</a> event.</p>
<dl class="section note"><dt>Note</dt><dd>Both the handles must be running on the same loop.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref</td><td>An initialized handle to be used to accept the connection. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stream_8hpp_source.html#l00221">221</a> of file <a class="el" href="stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<a id="a5f0abb05d8b07840cf0a36c64ec23fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0abb05d8b07840cf0a36c64ec23fc4">&#9670;&nbsp;</a></span>blocking()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classuvw_1_1StreamHandle.html">uvw::StreamHandle</a>&lt; T, U &gt;::blocking </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables or disables blocking mode for a stream. </p>
<p>When blocking mode is enabled all writes complete synchronously. The interface remains unchanged otherwise, e.g. completion or failure of the operation will still be reported through events which are emitted asynchronously.</p>
<p>See the official <a href="http://docs.libuv.org/en/v1.x/stream.html#c.uv_stream_set_blocking">documentation</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>True to enable blocking mode, false otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True in case of success, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stream_8hpp_source.html#l00446">446</a> of file <a class="el" href="stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<a id="ae7f3eeb7d21ca0bbbb7df591fade4e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7f3eeb7d21ca0bbbb7df591fade4e46">&#9670;&nbsp;</a></span>listen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuvw_1_1StreamHandle.html">uvw::StreamHandle</a>&lt; T, U &gt;::listen </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>backlog</em> = <code>DEFAULT_BACKLOG</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts listening for incoming connections. </p>
<p>When a new incoming connection is received, a <a class="el" href="structuvw_1_1ListenEvent.html" title="ListenEvent event. ">ListenEvent</a> event is emitted.<br />
 An <a class="el" href="structuvw_1_1ErrorEvent.html" title="The ErrorEvent event. ">ErrorEvent</a> event will be emitted in case of errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">backlog</td><td>Indicates the number of connections the kernel might queue, same as listen(2). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stream_8hpp_source.html#l00197">197</a> of file <a class="el" href="stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<a id="a2bce95db93fb64ee8b86c41b65a060c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bce95db93fb64ee8b86c41b65a060c8">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuvw_1_1StreamHandle.html">uvw::StreamHandle</a>&lt; T, U &gt;::read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts reading data from an incoming stream. </p>
<p>A <a class="el" href="structuvw_1_1DataEvent.html" title="DataEvent event. ">DataEvent</a> event will be emitted several times until there is no more data to read or <code><a class="el" href="classuvw_1_1StreamHandle.html#aa7ecf6a0a39f74707b79ff4e8f696bb8" title="Stops reading data from the stream. ">stop()</a></code> is called.<br />
 An <a class="el" href="structuvw_1_1EndEvent.html" title="EndEvent event. ">EndEvent</a> event will be emitted when there is no more data to read. </p>

<p class="definition">Definition at line <a class="el" href="stream_8hpp_source.html#l00232">232</a> of file <a class="el" href="stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<a id="a91efe7dfb93505779edbf603a6a1c515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91efe7dfb93505779edbf603a6a1c515">&#9670;&nbsp;</a></span>readable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classuvw_1_1StreamHandle.html">uvw::StreamHandle</a>&lt; T, U &gt;::readable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the stream is readable. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the stream is readable, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stream_8hpp_source.html#l00419">419</a> of file <a class="el" href="stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<a id="a3c1a1ddd951b0087c14e951610593653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1a1ddd951b0087c14e951610593653">&#9670;&nbsp;</a></span>shutdown()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuvw_1_1StreamHandle.html">uvw::StreamHandle</a>&lt; T, U &gt;::shutdown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shutdowns the outgoing (write) side of a duplex stream. </p>
<p>It waits for pending write requests to complete. The handle should refer to a initialized stream.<br />
 A <a class="el" href="structuvw_1_1ShutdownEvent.html" title="ShutdownEvent event. ">ShutdownEvent</a> event will be emitted after shutdown is complete. </p>

<p class="definition">Definition at line <a class="el" href="stream_8hpp_source.html#l00176">176</a> of file <a class="el" href="stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<a id="aa7ecf6a0a39f74707b79ff4e8f696bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ecf6a0a39f74707b79ff4e8f696bb8">&#9670;&nbsp;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuvw_1_1StreamHandle.html">uvw::StreamHandle</a>&lt; T, U &gt;::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stops reading data from the stream. </p>
<p>This function is idempotent and may be safely called on a stopped stream. </p>

<p class="definition">Definition at line <a class="el" href="stream_8hpp_source.html#l00241">241</a> of file <a class="el" href="stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<a id="a3f6f26113dc02442a93b7643842fb415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f6f26113dc02442a93b7643842fb415">&#9670;&nbsp;</a></span>tryWrite() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classuvw_1_1StreamHandle.html">uvw::StreamHandle</a>&lt; T, U &gt;::tryWrite </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; char[]&gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queues a write request if it can be completed immediately. </p>
<p>Same as <code><a class="el" href="classuvw_1_1StreamHandle.html#ac77b0d5368ab31774d5edecf35844705" title="Writes data to the stream. ">write()</a></code>, but won’t queue a write request if it can’t be completed immediately.<br />
 An <a class="el" href="structuvw_1_1ErrorEvent.html" title="The ErrorEvent event. ">ErrorEvent</a> event will be emitted in case of errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to be written to the stream. </td></tr>
    <tr><td class="paramname">len</td><td>The lenght of the submitted data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes written. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stream_8hpp_source.html#l00380">380</a> of file <a class="el" href="stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<a id="a72b95a0efb99c96a0427a8f44fd9ddb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72b95a0efb99c96a0427a8f44fd9ddb6">&#9670;&nbsp;</a></span>tryWrite() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classuvw_1_1StreamHandle.html">uvw::StreamHandle</a>&lt; T, U &gt;::tryWrite </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queues a write request if it can be completed immediately. </p>
<p>Same as <code><a class="el" href="classuvw_1_1StreamHandle.html#ac77b0d5368ab31774d5edecf35844705" title="Writes data to the stream. ">write()</a></code>, but won’t queue a write request if it can’t be completed immediately.<br />
 An <a class="el" href="structuvw_1_1ErrorEvent.html" title="The ErrorEvent event. ">ErrorEvent</a> event will be emitted in case of errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to be written to the stream. </td></tr>
    <tr><td class="paramname">len</td><td>The lenght of the submitted data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes written. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stream_8hpp_source.html#l00403">403</a> of file <a class="el" href="stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<a id="a5918e5e17773fdd8dc078d07809359ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5918e5e17773fdd8dc078d07809359ea">&#9670;&nbsp;</a></span>writable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classuvw_1_1StreamHandle.html">uvw::StreamHandle</a>&lt; T, U &gt;::writable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the stream is writable. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the stream is writable, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stream_8hpp_source.html#l00427">427</a> of file <a class="el" href="stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<a id="ac77b0d5368ab31774d5edecf35844705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac77b0d5368ab31774d5edecf35844705">&#9670;&nbsp;</a></span>write() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuvw_1_1StreamHandle.html">uvw::StreamHandle</a>&lt; T, U &gt;::write </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; char[]&gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes data to the stream. </p>
<p>Data are written in order. The handle takes the ownership of the data and it is in charge of delete them.</p>
<p>A <a class="el" href="structuvw_1_1WriteEvent.html" title="WriteEvent event. ">WriteEvent</a> event will be emitted when the data have been written.<br />
 An <a class="el" href="structuvw_1_1ErrorEvent.html" title="The ErrorEvent event. ">ErrorEvent</a> event will be emitted in case of errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to be written to the stream. </td></tr>
    <tr><td class="paramname">len</td><td>The lenght of the submitted data. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stream_8hpp_source.html#l00257">257</a> of file <a class="el" href="stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<a id="ad6b4f4c4ffb19990bef05c776662f85c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6b4f4c4ffb19990bef05c776662f85c">&#9670;&nbsp;</a></span>write() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuvw_1_1StreamHandle.html">uvw::StreamHandle</a>&lt; T, U &gt;::write </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes data to the stream. </p>
<p>Data are written in order. The handle doesn't take the ownership of the data. Be sure that their lifetime overcome the one of the request.</p>
<p>A <a class="el" href="structuvw_1_1WriteEvent.html" title="WriteEvent event. ">WriteEvent</a> event will be emitted when the data have been written.<br />
 An <a class="el" href="structuvw_1_1ErrorEvent.html" title="The ErrorEvent event. ">ErrorEvent</a> event will be emitted in case of errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to be written to the stream. </td></tr>
    <tr><td class="paramname">len</td><td>The lenght of the submitted data. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stream_8hpp_source.html#l00284">284</a> of file <a class="el" href="stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<a id="a13357c4a56712232c7733f03dc38c67b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13357c4a56712232c7733f03dc38c67b">&#9670;&nbsp;</a></span>write() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U&gt; </div>
<div class="memtemplate">
template&lt;typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuvw_1_1StreamHandle.html">uvw::StreamHandle</a>&lt; T, U &gt;::write </td>
          <td>(</td>
          <td class="paramtype">S &amp;&#160;</td>
          <td class="paramname"><em>send</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; char[]&gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extended write function for sending handles over a pipe handle. </p>
<p>The pipe must be initialized with <code>ipc == true</code>.</p>
<p><code>send</code> must be a <a class="el" href="classuvw_1_1TcpHandle.html" title="The TcpHandle handle. ">TcpHandle</a> or <a class="el" href="classuvw_1_1PipeHandle.html" title="The PipeHandle handle. ">PipeHandle</a> handle, which is a server or a connection (listening or connected state). Bound sockets or pipes will be assumed to be servers.</p>
<p>The handle takes the ownership of the data and it is in charge of delete them.</p>
<p>A <a class="el" href="structuvw_1_1WriteEvent.html" title="WriteEvent event. ">WriteEvent</a> event will be emitted when the data have been written.<br />
 An <a class="el" href="structuvw_1_1ErrorEvent.html" title="The ErrorEvent event. ">ErrorEvent</a> wvent will be emitted in case of errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">send</td><td>The handle over which to write data. </td></tr>
    <tr><td class="paramname">data</td><td>The data to be written to the stream. </td></tr>
    <tr><td class="paramname">len</td><td>The lenght of the submitted data. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stream_8hpp_source.html#l00319">319</a> of file <a class="el" href="stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<a id="a0086873dd2962189c92935bf6855c0c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0086873dd2962189c92935bf6855c0c4">&#9670;&nbsp;</a></span>write() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U&gt; </div>
<div class="memtemplate">
template&lt;typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuvw_1_1StreamHandle.html">uvw::StreamHandle</a>&lt; T, U &gt;::write </td>
          <td>(</td>
          <td class="paramtype">S &amp;&#160;</td>
          <td class="paramname"><em>send</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extended write function for sending handles over a pipe handle. </p>
<p>The pipe must be initialized with <code>ipc == true</code>.</p>
<p><code>send</code> must be a <a class="el" href="classuvw_1_1TcpHandle.html" title="The TcpHandle handle. ">TcpHandle</a> or <a class="el" href="classuvw_1_1PipeHandle.html" title="The PipeHandle handle. ">PipeHandle</a> handle, which is a server or a connection (listening or connected state). Bound sockets or pipes will be assumed to be servers.</p>
<p>The handle doesn't take the ownership of the data. Be sure that their lifetime overcome the one of the request.</p>
<p>A <a class="el" href="structuvw_1_1WriteEvent.html" title="WriteEvent event. ">WriteEvent</a> event will be emitted when the data have been written.<br />
 An <a class="el" href="structuvw_1_1ErrorEvent.html" title="The ErrorEvent event. ">ErrorEvent</a> wvent will be emitted in case of errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">send</td><td>The handle over which to write data. </td></tr>
    <tr><td class="paramname">data</td><td>The data to be written to the stream. </td></tr>
    <tr><td class="paramname">len</td><td>The lenght of the submitted data. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stream_8hpp_source.html#l00354">354</a> of file <a class="el" href="stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<a id="a6e976a472fd0712ed3a8995450695b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e976a472fd0712ed3a8995450695b9f">&#9670;&nbsp;</a></span>writeQueueSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classuvw_1_1StreamHandle.html">uvw::StreamHandle</a>&lt; T, U &gt;::writeQueueSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the amount of queued bytes waiting to be sent. </p>
<dl class="section return"><dt>Returns</dt><dd>Amount of queued bytes waiting to be sent. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stream_8hpp_source.html#l00454">454</a> of file <a class="el" href="stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/uvw/<a class="el" href="stream_8hpp_source.html">stream.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
