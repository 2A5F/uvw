<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>uvw: uvw::UDPHandle Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">uvw
   &#160;<span id="projectnumber">2.6.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceuvw.html">uvw</a></li><li class="navelem"><a class="el" href="classuvw_1_1UDPHandle.html">UDPHandle</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classuvw_1_1UDPHandle-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">uvw::UDPHandle Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classuvw_1_1UDPHandle.html" title="The UDPHandle handle.">UDPHandle</a> handle.  
 <a href="classuvw_1_1UDPHandle.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="udp_8h_source.html">udp.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for uvw::UDPHandle:</div>
<div class="dyncontent">
<div class="center"><img src="classuvw_1_1UDPHandle__inherit__graph.png" border="0" usemap="#uvw_1_1UDPHandle_inherit__map" alt="Inheritance graph"/></div>
<map name="uvw_1_1UDPHandle_inherit__map" id="uvw_1_1UDPHandle_inherit__map">
<area shape="rect" title="The UDPHandle handle." alt="" coords="246,273,377,300"/>
<area shape="rect" href="classuvw_1_1Handle.html" title=" " alt="" coords="214,184,409,225"/>
<area shape="rect" href="classuvw_1_1Resource.html" title=" " alt="" coords="109,95,319,136"/>
<area shape="rect" href="classuvw_1_1UnderlyingType.html" title=" " alt="" coords="5,5,199,47"/>
<area shape="rect" href="classuvw_1_1Emitter.html" title=" " alt="" coords="223,13,431,39"/>
<area shape="rect" href="structuvw_1_1BaseHandle.html" title="Untyped handle class." alt="" coords="343,102,477,129"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for uvw::UDPHandle:</div>
<div class="dyncontent">
<div class="center"><img src="classuvw_1_1UDPHandle__coll__graph.png" border="0" usemap="#uvw_1_1UDPHandle_coll__map" alt="Collaboration graph"/></div>
<map name="uvw_1_1UDPHandle_coll__map" id="uvw_1_1UDPHandle_coll__map">
<area shape="rect" title="The UDPHandle handle." alt="" coords="246,273,377,300"/>
<area shape="rect" href="classuvw_1_1Handle.html" title=" " alt="" coords="214,184,409,225"/>
<area shape="rect" href="classuvw_1_1Resource.html" title=" " alt="" coords="109,95,319,136"/>
<area shape="rect" href="classuvw_1_1UnderlyingType.html" title=" " alt="" coords="5,5,199,47"/>
<area shape="rect" href="classuvw_1_1Emitter.html" title=" " alt="" coords="223,13,431,39"/>
<area shape="rect" href="structuvw_1_1BaseHandle.html" title="Untyped handle class." alt="" coords="343,102,477,129"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a07efb83349ed0d28052d74bff7d9eeb1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1UDPHandle.html#a07efb83349ed0d28052d74bff7d9eeb1">init</a> ()</td></tr>
<tr class="memdesc:a07efb83349ed0d28052d74bff7d9eeb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the handle. The actual socket is created lazily.  <a href="classuvw_1_1UDPHandle.html#a07efb83349ed0d28052d74bff7d9eeb1">More...</a><br /></td></tr>
<tr class="separator:a07efb83349ed0d28052d74bff7d9eeb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae833e91e263788861227f91ee65adfd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1UDPHandle.html#ae833e91e263788861227f91ee65adfd5">open</a> (<a class="el" href="namespaceuvw.html#a2df38e5bba10fc959ef37074cf580097">OSSocketHandle</a> socket)</td></tr>
<tr class="memdesc:ae833e91e263788861227f91ee65adfd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens an existing file descriptor or SOCKET as a UDP handle.  <a href="classuvw_1_1UDPHandle.html#ae833e91e263788861227f91ee65adfd5">More...</a><br /></td></tr>
<tr class="separator:ae833e91e263788861227f91ee65adfd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c7c261aac3305dd607f0a0f4782eb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1UDPHandle.html#a53c7c261aac3305dd607f0a0f4782eb1">bind</a> (const sockaddr &amp;addr, <a class="el" href="classuvw_1_1Flags.html">Flags</a>&lt; Bind &gt; opts=<a class="el" href="classuvw_1_1Flags.html">Flags</a>&lt; Bind &gt;{})</td></tr>
<tr class="memdesc:a53c7c261aac3305dd607f0a0f4782eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds the UDP handle to an IP address and port.  <a href="classuvw_1_1UDPHandle.html#a53c7c261aac3305dd607f0a0f4782eb1">More...</a><br /></td></tr>
<tr class="separator:a53c7c261aac3305dd607f0a0f4782eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf587231065893625a14597eb8ab3a21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1UDPHandle.html#abf587231065893625a14597eb8ab3a21">connect</a> (const sockaddr &amp;addr)</td></tr>
<tr class="memdesc:abf587231065893625a14597eb8ab3a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associates the handle to a remote address and port (either <a class="el" href="structuvw_1_1IPv4.html" title="The IPv4 tag.">IPv4</a> or <a class="el" href="structuvw_1_1IPv6.html" title="The IPv6 tag.">IPv6</a>).  <a href="classuvw_1_1UDPHandle.html#abf587231065893625a14597eb8ab3a21">More...</a><br /></td></tr>
<tr class="separator:abf587231065893625a14597eb8ab3a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f636096987eb3fcbe1872f3868c13e"><td class="memTemplParams" colspan="2">template&lt;typename I  = IPv4&gt; </td></tr>
<tr class="memitem:a34f636096987eb3fcbe1872f3868c13e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1UDPHandle.html#a34f636096987eb3fcbe1872f3868c13e">connect</a> (std::string ip, unsigned int port)</td></tr>
<tr class="memdesc:a34f636096987eb3fcbe1872f3868c13e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associates the handle to a remote address and port (either <a class="el" href="structuvw_1_1IPv4.html" title="The IPv4 tag.">IPv4</a> or <a class="el" href="structuvw_1_1IPv6.html" title="The IPv6 tag.">IPv6</a>).  <a href="classuvw_1_1UDPHandle.html#a34f636096987eb3fcbe1872f3868c13e">More...</a><br /></td></tr>
<tr class="separator:a34f636096987eb3fcbe1872f3868c13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439c6e0f4eaa49db4ddd71a3c326f07a"><td class="memTemplParams" colspan="2">template&lt;typename I  = IPv4&gt; </td></tr>
<tr class="memitem:a439c6e0f4eaa49db4ddd71a3c326f07a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1UDPHandle.html#a439c6e0f4eaa49db4ddd71a3c326f07a">connect</a> (<a class="el" href="structuvw_1_1Addr.html">Addr</a> addr)</td></tr>
<tr class="memdesc:a439c6e0f4eaa49db4ddd71a3c326f07a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associates the handle to a remote address and port (either <a class="el" href="structuvw_1_1IPv4.html" title="The IPv4 tag.">IPv4</a> or <a class="el" href="structuvw_1_1IPv6.html" title="The IPv6 tag.">IPv6</a>).  <a href="classuvw_1_1UDPHandle.html#a439c6e0f4eaa49db4ddd71a3c326f07a">More...</a><br /></td></tr>
<tr class="separator:a439c6e0f4eaa49db4ddd71a3c326f07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0a9ec23746b395ec91b5e62b6b95d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1UDPHandle.html#aae0a9ec23746b395ec91b5e62b6b95d5">disconnect</a> ()</td></tr>
<tr class="memdesc:aae0a9ec23746b395ec91b5e62b6b95d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects the handle.  <a href="classuvw_1_1UDPHandle.html#aae0a9ec23746b395ec91b5e62b6b95d5">More...</a><br /></td></tr>
<tr class="separator:aae0a9ec23746b395ec91b5e62b6b95d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764c71bb11f33f1dd7ac6c0fdc2427db"><td class="memTemplParams" colspan="2">template&lt;typename I  = IPv4&gt; </td></tr>
<tr class="memitem:a764c71bb11f33f1dd7ac6c0fdc2427db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structuvw_1_1Addr.html">Addr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1UDPHandle.html#a764c71bb11f33f1dd7ac6c0fdc2427db">peer</a> () const noexcept</td></tr>
<tr class="memdesc:a764c71bb11f33f1dd7ac6c0fdc2427db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the remote address to which the handle is connected, if any.  <a href="classuvw_1_1UDPHandle.html#a764c71bb11f33f1dd7ac6c0fdc2427db">More...</a><br /></td></tr>
<tr class="separator:a764c71bb11f33f1dd7ac6c0fdc2427db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57cc7ee394e48ed5f096a0b6b6ab510c"><td class="memTemplParams" colspan="2">template&lt;typename I  = IPv4&gt; </td></tr>
<tr class="memitem:a57cc7ee394e48ed5f096a0b6b6ab510c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1UDPHandle.html#a57cc7ee394e48ed5f096a0b6b6ab510c">bind</a> (std::string ip, unsigned int port, <a class="el" href="classuvw_1_1Flags.html">Flags</a>&lt; Bind &gt; opts=<a class="el" href="classuvw_1_1Flags.html">Flags</a>&lt; Bind &gt;{})</td></tr>
<tr class="memdesc:a57cc7ee394e48ed5f096a0b6b6ab510c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds the UDP handle to an IP address and port.  <a href="classuvw_1_1UDPHandle.html#a57cc7ee394e48ed5f096a0b6b6ab510c">More...</a><br /></td></tr>
<tr class="separator:a57cc7ee394e48ed5f096a0b6b6ab510c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce77d17a192d820e9de9bb19b33e563"><td class="memTemplParams" colspan="2">template&lt;typename I  = IPv4&gt; </td></tr>
<tr class="memitem:a6ce77d17a192d820e9de9bb19b33e563"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1UDPHandle.html#a6ce77d17a192d820e9de9bb19b33e563">bind</a> (<a class="el" href="structuvw_1_1Addr.html">Addr</a> addr, <a class="el" href="classuvw_1_1Flags.html">Flags</a>&lt; Bind &gt; opts=<a class="el" href="classuvw_1_1Flags.html">Flags</a>&lt; Bind &gt;{})</td></tr>
<tr class="memdesc:a6ce77d17a192d820e9de9bb19b33e563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds the UDP handle to an IP address and port.  <a href="classuvw_1_1UDPHandle.html#a6ce77d17a192d820e9de9bb19b33e563">More...</a><br /></td></tr>
<tr class="separator:a6ce77d17a192d820e9de9bb19b33e563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8494b9b51e0f9e7572d758e710e34bb"><td class="memTemplParams" colspan="2">template&lt;typename I  = IPv4&gt; </td></tr>
<tr class="memitem:aa8494b9b51e0f9e7572d758e710e34bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structuvw_1_1Addr.html">Addr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1UDPHandle.html#aa8494b9b51e0f9e7572d758e710e34bb">sock</a> () const noexcept</td></tr>
<tr class="memdesc:aa8494b9b51e0f9e7572d758e710e34bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local IP and port of the UDP handle.  <a href="classuvw_1_1UDPHandle.html#aa8494b9b51e0f9e7572d758e710e34bb">More...</a><br /></td></tr>
<tr class="separator:aa8494b9b51e0f9e7572d758e710e34bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a4f4b90ebf62e8021b03bb5b4dee5b"><td class="memTemplParams" colspan="2">template&lt;typename I  = IPv4&gt; </td></tr>
<tr class="memitem:af4a4f4b90ebf62e8021b03bb5b4dee5b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1UDPHandle.html#af4a4f4b90ebf62e8021b03bb5b4dee5b">multicastMembership</a> (std::string multicast, std::string iface, Membership membership)</td></tr>
<tr class="memdesc:af4a4f4b90ebf62e8021b03bb5b4dee5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets membership for a multicast address.  <a href="classuvw_1_1UDPHandle.html#af4a4f4b90ebf62e8021b03bb5b4dee5b">More...</a><br /></td></tr>
<tr class="separator:af4a4f4b90ebf62e8021b03bb5b4dee5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1736dbefd63e4df9c0a73006ff7ce85"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1UDPHandle.html#af1736dbefd63e4df9c0a73006ff7ce85">multicastLoop</a> (bool enable=true)</td></tr>
<tr class="memdesc:af1736dbefd63e4df9c0a73006ff7ce85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets IP multicast loop flag.  <a href="classuvw_1_1UDPHandle.html#af1736dbefd63e4df9c0a73006ff7ce85">More...</a><br /></td></tr>
<tr class="separator:af1736dbefd63e4df9c0a73006ff7ce85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a112900e1beea3c2c636bff6419491"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1UDPHandle.html#a70a112900e1beea3c2c636bff6419491">multicastTtl</a> (int val)</td></tr>
<tr class="memdesc:a70a112900e1beea3c2c636bff6419491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the multicast ttl.  <a href="classuvw_1_1UDPHandle.html#a70a112900e1beea3c2c636bff6419491">More...</a><br /></td></tr>
<tr class="separator:a70a112900e1beea3c2c636bff6419491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7452f7e65290c913ab6a4df092cd57ee"><td class="memTemplParams" colspan="2">template&lt;typename I  = IPv4&gt; </td></tr>
<tr class="memitem:a7452f7e65290c913ab6a4df092cd57ee"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1UDPHandle.html#a7452f7e65290c913ab6a4df092cd57ee">multicastInterface</a> (std::string iface)</td></tr>
<tr class="memdesc:a7452f7e65290c913ab6a4df092cd57ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the multicast interface to send or receive data on.  <a href="classuvw_1_1UDPHandle.html#a7452f7e65290c913ab6a4df092cd57ee">More...</a><br /></td></tr>
<tr class="separator:a7452f7e65290c913ab6a4df092cd57ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a50d9ccea29757480b69bfc0de2374"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1UDPHandle.html#a41a50d9ccea29757480b69bfc0de2374">broadcast</a> (bool enable=false)</td></tr>
<tr class="memdesc:a41a50d9ccea29757480b69bfc0de2374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets broadcast on or off.  <a href="classuvw_1_1UDPHandle.html#a41a50d9ccea29757480b69bfc0de2374">More...</a><br /></td></tr>
<tr class="separator:a41a50d9ccea29757480b69bfc0de2374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c37745be6ee35cb5ba5c2cece2c555"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1UDPHandle.html#a95c37745be6ee35cb5ba5c2cece2c555">ttl</a> (int val)</td></tr>
<tr class="memdesc:a95c37745be6ee35cb5ba5c2cece2c555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the time to live.  <a href="classuvw_1_1UDPHandle.html#a95c37745be6ee35cb5ba5c2cece2c555">More...</a><br /></td></tr>
<tr class="separator:a95c37745be6ee35cb5ba5c2cece2c555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8092d01bdd9b790f3ece69ee13ea9a28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1UDPHandle.html#a8092d01bdd9b790f3ece69ee13ea9a28">send</a> (const sockaddr &amp;addr, std::unique_ptr&lt; char[]&gt; <a class="el" href="classuvw_1_1Resource.html#a0d6bb9bf4bcdf98afc37d3d267178813">data</a>, unsigned int len)</td></tr>
<tr class="memdesc:a8092d01bdd9b790f3ece69ee13ea9a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends data over the UDP socket.  <a href="classuvw_1_1UDPHandle.html#a8092d01bdd9b790f3ece69ee13ea9a28">More...</a><br /></td></tr>
<tr class="separator:a8092d01bdd9b790f3ece69ee13ea9a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc48b8410e35903b383664191b452bcb"><td class="memTemplParams" colspan="2">template&lt;typename I  = IPv4&gt; </td></tr>
<tr class="memitem:acc48b8410e35903b383664191b452bcb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1UDPHandle.html#acc48b8410e35903b383664191b452bcb">send</a> (std::string ip, unsigned int port, std::unique_ptr&lt; char[]&gt; <a class="el" href="classuvw_1_1Resource.html#a0d6bb9bf4bcdf98afc37d3d267178813">data</a>, unsigned int len)</td></tr>
<tr class="memdesc:acc48b8410e35903b383664191b452bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends data over the UDP socket.  <a href="classuvw_1_1UDPHandle.html#acc48b8410e35903b383664191b452bcb">More...</a><br /></td></tr>
<tr class="separator:acc48b8410e35903b383664191b452bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899e92765c79155792032711b589b62a"><td class="memTemplParams" colspan="2">template&lt;typename I  = IPv4&gt; </td></tr>
<tr class="memitem:a899e92765c79155792032711b589b62a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1UDPHandle.html#a899e92765c79155792032711b589b62a">send</a> (<a class="el" href="structuvw_1_1Addr.html">Addr</a> addr, std::unique_ptr&lt; char[]&gt; <a class="el" href="classuvw_1_1Resource.html#a0d6bb9bf4bcdf98afc37d3d267178813">data</a>, unsigned int len)</td></tr>
<tr class="memdesc:a899e92765c79155792032711b589b62a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends data over the UDP socket.  <a href="classuvw_1_1UDPHandle.html#a899e92765c79155792032711b589b62a">More...</a><br /></td></tr>
<tr class="separator:a899e92765c79155792032711b589b62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9855f3277e5a4e1e6a47ec9207d2d57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1UDPHandle.html#ac9855f3277e5a4e1e6a47ec9207d2d57">send</a> (const sockaddr &amp;addr, char *<a class="el" href="classuvw_1_1Resource.html#a0d6bb9bf4bcdf98afc37d3d267178813">data</a>, unsigned int len)</td></tr>
<tr class="memdesc:ac9855f3277e5a4e1e6a47ec9207d2d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends data over the UDP socket.  <a href="classuvw_1_1UDPHandle.html#ac9855f3277e5a4e1e6a47ec9207d2d57">More...</a><br /></td></tr>
<tr class="separator:ac9855f3277e5a4e1e6a47ec9207d2d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55884efbab16ac00a157b0bbe5413aa6"><td class="memTemplParams" colspan="2">template&lt;typename I  = IPv4&gt; </td></tr>
<tr class="memitem:a55884efbab16ac00a157b0bbe5413aa6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1UDPHandle.html#a55884efbab16ac00a157b0bbe5413aa6">send</a> (std::string ip, unsigned int port, char *<a class="el" href="classuvw_1_1Resource.html#a0d6bb9bf4bcdf98afc37d3d267178813">data</a>, unsigned int len)</td></tr>
<tr class="memdesc:a55884efbab16ac00a157b0bbe5413aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends data over the UDP socket.  <a href="classuvw_1_1UDPHandle.html#a55884efbab16ac00a157b0bbe5413aa6">More...</a><br /></td></tr>
<tr class="separator:a55884efbab16ac00a157b0bbe5413aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6967ada6a6567b09bd896f33dea56ba2"><td class="memTemplParams" colspan="2">template&lt;typename I  = IPv4&gt; </td></tr>
<tr class="memitem:a6967ada6a6567b09bd896f33dea56ba2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1UDPHandle.html#a6967ada6a6567b09bd896f33dea56ba2">send</a> (<a class="el" href="structuvw_1_1Addr.html">Addr</a> addr, char *<a class="el" href="classuvw_1_1Resource.html#a0d6bb9bf4bcdf98afc37d3d267178813">data</a>, unsigned int len)</td></tr>
<tr class="memdesc:a6967ada6a6567b09bd896f33dea56ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends data over the UDP socket.  <a href="classuvw_1_1UDPHandle.html#a6967ada6a6567b09bd896f33dea56ba2">More...</a><br /></td></tr>
<tr class="separator:a6967ada6a6567b09bd896f33dea56ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ee2b1d037fd4c2d2f7487076241809"><td class="memTemplParams" colspan="2">template&lt;typename I  = IPv4&gt; </td></tr>
<tr class="memitem:a57ee2b1d037fd4c2d2f7487076241809"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1UDPHandle.html#a57ee2b1d037fd4c2d2f7487076241809">trySend</a> (const sockaddr &amp;addr, std::unique_ptr&lt; char[]&gt; <a class="el" href="classuvw_1_1Resource.html#a0d6bb9bf4bcdf98afc37d3d267178813">data</a>, unsigned int len)</td></tr>
<tr class="memdesc:a57ee2b1d037fd4c2d2f7487076241809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends data over the UDP socket.  <a href="classuvw_1_1UDPHandle.html#a57ee2b1d037fd4c2d2f7487076241809">More...</a><br /></td></tr>
<tr class="separator:a57ee2b1d037fd4c2d2f7487076241809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89b82ecf73039581c7207ef1c3d7cfd"><td class="memTemplParams" colspan="2">template&lt;typename I  = IPv4&gt; </td></tr>
<tr class="memitem:aa89b82ecf73039581c7207ef1c3d7cfd"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1UDPHandle.html#aa89b82ecf73039581c7207ef1c3d7cfd">trySend</a> (std::string ip, unsigned int port, std::unique_ptr&lt; char[]&gt; <a class="el" href="classuvw_1_1Resource.html#a0d6bb9bf4bcdf98afc37d3d267178813">data</a>, unsigned int len)</td></tr>
<tr class="memdesc:aa89b82ecf73039581c7207ef1c3d7cfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends data over the UDP socket.  <a href="classuvw_1_1UDPHandle.html#aa89b82ecf73039581c7207ef1c3d7cfd">More...</a><br /></td></tr>
<tr class="separator:aa89b82ecf73039581c7207ef1c3d7cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c107fe0a7ca4db749dbf2e1fa8d32c"><td class="memTemplParams" colspan="2">template&lt;typename I  = IPv4&gt; </td></tr>
<tr class="memitem:a39c107fe0a7ca4db749dbf2e1fa8d32c"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1UDPHandle.html#a39c107fe0a7ca4db749dbf2e1fa8d32c">trySend</a> (<a class="el" href="structuvw_1_1Addr.html">Addr</a> addr, std::unique_ptr&lt; char[]&gt; <a class="el" href="classuvw_1_1Resource.html#a0d6bb9bf4bcdf98afc37d3d267178813">data</a>, unsigned int len)</td></tr>
<tr class="memdesc:a39c107fe0a7ca4db749dbf2e1fa8d32c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends data over the UDP socket.  <a href="classuvw_1_1UDPHandle.html#a39c107fe0a7ca4db749dbf2e1fa8d32c">More...</a><br /></td></tr>
<tr class="separator:a39c107fe0a7ca4db749dbf2e1fa8d32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46fad3e1568cce4fee79047b579627c1"><td class="memTemplParams" colspan="2">template&lt;typename I  = IPv4&gt; </td></tr>
<tr class="memitem:a46fad3e1568cce4fee79047b579627c1"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1UDPHandle.html#a46fad3e1568cce4fee79047b579627c1">trySend</a> (const sockaddr &amp;addr, char *<a class="el" href="classuvw_1_1Resource.html#a0d6bb9bf4bcdf98afc37d3d267178813">data</a>, unsigned int len)</td></tr>
<tr class="memdesc:a46fad3e1568cce4fee79047b579627c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends data over the UDP socket.  <a href="classuvw_1_1UDPHandle.html#a46fad3e1568cce4fee79047b579627c1">More...</a><br /></td></tr>
<tr class="separator:a46fad3e1568cce4fee79047b579627c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7de6f96f8c02e16b3146d144c49bc9"><td class="memTemplParams" colspan="2">template&lt;typename I  = IPv4&gt; </td></tr>
<tr class="memitem:a6d7de6f96f8c02e16b3146d144c49bc9"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1UDPHandle.html#a6d7de6f96f8c02e16b3146d144c49bc9">trySend</a> (std::string ip, unsigned int port, char *<a class="el" href="classuvw_1_1Resource.html#a0d6bb9bf4bcdf98afc37d3d267178813">data</a>, unsigned int len)</td></tr>
<tr class="memdesc:a6d7de6f96f8c02e16b3146d144c49bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends data over the UDP socket.  <a href="classuvw_1_1UDPHandle.html#a6d7de6f96f8c02e16b3146d144c49bc9">More...</a><br /></td></tr>
<tr class="separator:a6d7de6f96f8c02e16b3146d144c49bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942992c0897638726a9cfb470e110a37"><td class="memTemplParams" colspan="2">template&lt;typename I  = IPv4&gt; </td></tr>
<tr class="memitem:a942992c0897638726a9cfb470e110a37"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1UDPHandle.html#a942992c0897638726a9cfb470e110a37">trySend</a> (<a class="el" href="structuvw_1_1Addr.html">Addr</a> addr, char *<a class="el" href="classuvw_1_1Resource.html#a0d6bb9bf4bcdf98afc37d3d267178813">data</a>, unsigned int len)</td></tr>
<tr class="memdesc:a942992c0897638726a9cfb470e110a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends data over the UDP socket.  <a href="classuvw_1_1UDPHandle.html#a942992c0897638726a9cfb470e110a37">More...</a><br /></td></tr>
<tr class="separator:a942992c0897638726a9cfb470e110a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b0ff1e1375f0d2a3c4425f6a5e5489"><td class="memTemplParams" colspan="2">template&lt;typename I  = IPv4&gt; </td></tr>
<tr class="memitem:a93b0ff1e1375f0d2a3c4425f6a5e5489"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1UDPHandle.html#a93b0ff1e1375f0d2a3c4425f6a5e5489">recv</a> ()</td></tr>
<tr class="memdesc:a93b0ff1e1375f0d2a3c4425f6a5e5489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares for receiving data.  <a href="classuvw_1_1UDPHandle.html#a93b0ff1e1375f0d2a3c4425f6a5e5489">More...</a><br /></td></tr>
<tr class="separator:a93b0ff1e1375f0d2a3c4425f6a5e5489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23646fc83bf9aede62f01d2e3db1f7dc"><td class="memItemLeft" align="right" valign="top"><a id="a23646fc83bf9aede62f01d2e3db1f7dc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1UDPHandle.html#a23646fc83bf9aede62f01d2e3db1f7dc">stop</a> ()</td></tr>
<tr class="memdesc:a23646fc83bf9aede62f01d2e3db1f7dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops listening for incoming datagrams. <br /></td></tr>
<tr class="separator:a23646fc83bf9aede62f01d2e3db1f7dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e89abbcd88eacf11ada45cd5c65fb3e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1UDPHandle.html#a4e89abbcd88eacf11ada45cd5c65fb3e">sendQueueSize</a> () const noexcept</td></tr>
<tr class="memdesc:a4e89abbcd88eacf11ada45cd5c65fb3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of bytes queued for sending.  <a href="classuvw_1_1UDPHandle.html#a4e89abbcd88eacf11ada45cd5c65fb3e">More...</a><br /></td></tr>
<tr class="separator:a4e89abbcd88eacf11ada45cd5c65fb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66bcf98d5a258492842fe6ae022fb961"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1UDPHandle.html#a66bcf98d5a258492842fe6ae022fb961">sendQueueCount</a> () const noexcept</td></tr>
<tr class="memdesc:a66bcf98d5a258492842fe6ae022fb961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of send requests currently in the queue awaiting to be processed.  <a href="classuvw_1_1UDPHandle.html#a66bcf98d5a258492842fe6ae022fb961">More...</a><br /></td></tr>
<tr class="separator:a66bcf98d5a258492842fe6ae022fb961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classuvw_1_1Handle"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classuvw_1_1Handle')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classuvw_1_1Handle.html">uvw::Handle&lt; UDPHandle, uv_udp_t &gt;</a></td></tr>
<tr class="memitem:a96162bff13f6bf9a53be386765f01030 inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceuvw.html#aa3ae4a038de60a69b2513a039add1e48">HandleCategory</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#a96162bff13f6bf9a53be386765f01030">category</a> () const noexcept override</td></tr>
<tr class="memdesc:a96162bff13f6bf9a53be386765f01030 inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the category of the handle.  <a href="classuvw_1_1Handle.html#a96162bff13f6bf9a53be386765f01030">More...</a><br /></td></tr>
<tr class="separator:a96162bff13f6bf9a53be386765f01030 inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9056993d6077e8bee8bd77c9b03f2797 inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top">HandleType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#a9056993d6077e8bee8bd77c9b03f2797">type</a> () const noexcept override</td></tr>
<tr class="memdesc:a9056993d6077e8bee8bd77c9b03f2797 inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of the handle.  <a href="classuvw_1_1Handle.html#a9056993d6077e8bee8bd77c9b03f2797">More...</a><br /></td></tr>
<tr class="separator:a9056993d6077e8bee8bd77c9b03f2797 inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18132668364682aae1235f71ff35c903 inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#a18132668364682aae1235f71ff35c903">active</a> () const noexcept override</td></tr>
<tr class="memdesc:a18132668364682aae1235f71ff35c903 inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the handle is active.  <a href="classuvw_1_1Handle.html#a18132668364682aae1235f71ff35c903">More...</a><br /></td></tr>
<tr class="separator:a18132668364682aae1235f71ff35c903 inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b17026726b0999d1dc20c82b84ef0e inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#a94b17026726b0999d1dc20c82b84ef0e">closing</a> () const noexcept override</td></tr>
<tr class="memdesc:a94b17026726b0999d1dc20c82b84ef0e inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a handle is closing or closed.  <a href="classuvw_1_1Handle.html#a94b17026726b0999d1dc20c82b84ef0e">More...</a><br /></td></tr>
<tr class="separator:a94b17026726b0999d1dc20c82b84ef0e inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b7518a56ad891700c40a1578a1d2f1 inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#a83b7518a56ad891700c40a1578a1d2f1">close</a> () noexcept override</td></tr>
<tr class="memdesc:a83b7518a56ad891700c40a1578a1d2f1 inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request handle to be closed.  <a href="classuvw_1_1Handle.html#a83b7518a56ad891700c40a1578a1d2f1">More...</a><br /></td></tr>
<tr class="separator:a83b7518a56ad891700c40a1578a1d2f1 inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd04810b141d54cac4b51c69259f15e9 inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#acd04810b141d54cac4b51c69259f15e9">reference</a> () noexcept override</td></tr>
<tr class="memdesc:acd04810b141d54cac4b51c69259f15e9 inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference the given handle.  <a href="classuvw_1_1Handle.html#acd04810b141d54cac4b51c69259f15e9">More...</a><br /></td></tr>
<tr class="separator:acd04810b141d54cac4b51c69259f15e9 inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4bebc0f0cf639fcf38fd839017857e0 inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#af4bebc0f0cf639fcf38fd839017857e0">unreference</a> () noexcept override</td></tr>
<tr class="memdesc:af4bebc0f0cf639fcf38fd839017857e0 inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unreference the given handle.  <a href="classuvw_1_1Handle.html#af4bebc0f0cf639fcf38fd839017857e0">More...</a><br /></td></tr>
<tr class="separator:af4bebc0f0cf639fcf38fd839017857e0 inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44c23189e6c77b5a3807bb184366fd0 inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#ad44c23189e6c77b5a3807bb184366fd0">referenced</a> () const noexcept override</td></tr>
<tr class="memdesc:ad44c23189e6c77b5a3807bb184366fd0 inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given handle referenced.  <a href="classuvw_1_1Handle.html#ad44c23189e6c77b5a3807bb184366fd0">More...</a><br /></td></tr>
<tr class="separator:ad44c23189e6c77b5a3807bb184366fd0 inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9f911fc627f3feb32fefd67a7d5344 inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#aaf9f911fc627f3feb32fefd67a7d5344">size</a> () const noexcept</td></tr>
<tr class="memdesc:aaf9f911fc627f3feb32fefd67a7d5344 inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the underlying handle type.  <a href="classuvw_1_1Handle.html#aaf9f911fc627f3feb32fefd67a7d5344">More...</a><br /></td></tr>
<tr class="separator:aaf9f911fc627f3feb32fefd67a7d5344 inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381427eccddbc061341642a0647eb5c5 inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#a381427eccddbc061341642a0647eb5c5">sendBufferSize</a> ()</td></tr>
<tr class="memdesc:a381427eccddbc061341642a0647eb5c5 inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the send buffer used for the socket.  <a href="classuvw_1_1Handle.html#a381427eccddbc061341642a0647eb5c5">More...</a><br /></td></tr>
<tr class="separator:a381427eccddbc061341642a0647eb5c5 inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5101de6d8dea3bdd2bca444cde821db inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#ac5101de6d8dea3bdd2bca444cde821db">sendBufferSize</a> (int value)</td></tr>
<tr class="memdesc:ac5101de6d8dea3bdd2bca444cde821db inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the send buffer used for the socket.  <a href="classuvw_1_1Handle.html#ac5101de6d8dea3bdd2bca444cde821db">More...</a><br /></td></tr>
<tr class="separator:ac5101de6d8dea3bdd2bca444cde821db inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf07222a2587ca1eb80aec5a9af892e7 inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#adf07222a2587ca1eb80aec5a9af892e7">recvBufferSize</a> ()</td></tr>
<tr class="memdesc:adf07222a2587ca1eb80aec5a9af892e7 inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the receive buffer used for the socket.  <a href="classuvw_1_1Handle.html#adf07222a2587ca1eb80aec5a9af892e7">More...</a><br /></td></tr>
<tr class="separator:adf07222a2587ca1eb80aec5a9af892e7 inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a549b5f46f62b8474bad8775c6e4ff1a9 inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#a549b5f46f62b8474bad8775c6e4ff1a9">recvBufferSize</a> (int value)</td></tr>
<tr class="memdesc:a549b5f46f62b8474bad8775c6e4ff1a9 inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the receive buffer used for the socket.  <a href="classuvw_1_1Handle.html#a549b5f46f62b8474bad8775c6e4ff1a9">More...</a><br /></td></tr>
<tr class="separator:a549b5f46f62b8474bad8775c6e4ff1a9 inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33f8f753d3a19a0daece518f4a87bee inherit pub_methods_classuvw_1_1Handle"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceuvw.html#ad4b1016f485b28ad7dfd320a593b152b">OSFileDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Handle.html#ab33f8f753d3a19a0daece518f4a87bee">fileno</a> () const</td></tr>
<tr class="memdesc:ab33f8f753d3a19a0daece518f4a87bee inherit pub_methods_classuvw_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the platform dependent file descriptor equivalent.  <a href="classuvw_1_1Handle.html#ab33f8f753d3a19a0daece518f4a87bee">More...</a><br /></td></tr>
<tr class="separator:ab33f8f753d3a19a0daece518f4a87bee inherit pub_methods_classuvw_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classuvw_1_1Resource"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classuvw_1_1Resource')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classuvw_1_1Resource.html">uvw::Resource&lt; UDPHandle, uv_udp_t &gt;</a></td></tr>
<tr class="memitem:a0d6bb9bf4bcdf98afc37d3d267178813 inherit pub_methods_classuvw_1_1Resource"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; R &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Resource.html#a0d6bb9bf4bcdf98afc37d3d267178813">data</a> () const</td></tr>
<tr class="memdesc:a0d6bb9bf4bcdf98afc37d3d267178813 inherit pub_methods_classuvw_1_1Resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets user-defined data. <code>uvw</code> won't use this field in any case.  <a href="classuvw_1_1Resource.html#a0d6bb9bf4bcdf98afc37d3d267178813">More...</a><br /></td></tr>
<tr class="separator:a0d6bb9bf4bcdf98afc37d3d267178813 inherit pub_methods_classuvw_1_1Resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7b97267eb68d987d2f85b1161e55ee inherit pub_methods_classuvw_1_1Resource"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Resource.html#a7f7b97267eb68d987d2f85b1161e55ee">data</a> (std::shared_ptr&lt; void &gt; uData)</td></tr>
<tr class="memdesc:a7f7b97267eb68d987d2f85b1161e55ee inherit pub_methods_classuvw_1_1Resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets arbitrary data. <code>uvw</code> won't use this field in any case.  <a href="classuvw_1_1Resource.html#a7f7b97267eb68d987d2f85b1161e55ee">More...</a><br /></td></tr>
<tr class="separator:a7f7b97267eb68d987d2f85b1161e55ee inherit pub_methods_classuvw_1_1Resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classuvw_1_1UnderlyingType"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classuvw_1_1UnderlyingType')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classuvw_1_1UnderlyingType.html">uvw::UnderlyingType&lt; UDPHandle, uv_udp_t &gt;</a></td></tr>
<tr class="memitem:aab78fbfffb3c03d78aab515e605ecb18 inherit pub_methods_classuvw_1_1UnderlyingType"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuvw_1_1Loop.html">Loop</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1UnderlyingType.html#aab78fbfffb3c03d78aab515e605ecb18">loop</a> () const noexcept</td></tr>
<tr class="memdesc:aab78fbfffb3c03d78aab515e605ecb18 inherit pub_methods_classuvw_1_1UnderlyingType"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the loop from which the resource was originated.  <a href="classuvw_1_1UnderlyingType.html#aab78fbfffb3c03d78aab515e605ecb18">More...</a><br /></td></tr>
<tr class="separator:aab78fbfffb3c03d78aab515e605ecb18 inherit pub_methods_classuvw_1_1UnderlyingType"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2dddf23a571afb113c8b9c5e83f056f inherit pub_methods_classuvw_1_1UnderlyingType"><td class="memItemLeft" align="right" valign="top">const uv_udp_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1UnderlyingType.html#ab2dddf23a571afb113c8b9c5e83f056f">raw</a> () const noexcept</td></tr>
<tr class="memdesc:ab2dddf23a571afb113c8b9c5e83f056f inherit pub_methods_classuvw_1_1UnderlyingType"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the underlying raw data structure.  <a href="classuvw_1_1UnderlyingType.html#ab2dddf23a571afb113c8b9c5e83f056f">More...</a><br /></td></tr>
<tr class="separator:ab2dddf23a571afb113c8b9c5e83f056f inherit pub_methods_classuvw_1_1UnderlyingType"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ac17a623e508fa410453f8c17e5970 inherit pub_methods_classuvw_1_1UnderlyingType"><td class="memItemLeft" align="right" valign="top">uv_udp_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1UnderlyingType.html#a78ac17a623e508fa410453f8c17e5970">raw</a> () noexcept</td></tr>
<tr class="memdesc:a78ac17a623e508fa410453f8c17e5970 inherit pub_methods_classuvw_1_1UnderlyingType"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the underlying raw data structure.  <a href="classuvw_1_1UnderlyingType.html#a78ac17a623e508fa410453f8c17e5970">More...</a><br /></td></tr>
<tr class="separator:a78ac17a623e508fa410453f8c17e5970 inherit pub_methods_classuvw_1_1UnderlyingType"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classuvw_1_1Emitter"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classuvw_1_1Emitter')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classuvw_1_1Emitter.html">uvw::Emitter&lt; UDPHandle &gt;</a></td></tr>
<tr class="memitem:af6ba3eecb542efbef8d62ae905d8a8cd inherit pub_methods_classuvw_1_1Emitter"><td class="memItemLeft" align="right" valign="top">Connection&lt; E &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Emitter.html#af6ba3eecb542efbef8d62ae905d8a8cd">on</a> (Listener&lt; E &gt; f)</td></tr>
<tr class="memdesc:af6ba3eecb542efbef8d62ae905d8a8cd inherit pub_methods_classuvw_1_1Emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a long-lived listener with the event emitter.  <a href="classuvw_1_1Emitter.html#af6ba3eecb542efbef8d62ae905d8a8cd">More...</a><br /></td></tr>
<tr class="separator:af6ba3eecb542efbef8d62ae905d8a8cd inherit pub_methods_classuvw_1_1Emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e4ed59b5bb5cdc5ee4b0dd71a38472 inherit pub_methods_classuvw_1_1Emitter"><td class="memItemLeft" align="right" valign="top">Connection&lt; E &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Emitter.html#a79e4ed59b5bb5cdc5ee4b0dd71a38472">once</a> (Listener&lt; E &gt; f)</td></tr>
<tr class="memdesc:a79e4ed59b5bb5cdc5ee4b0dd71a38472 inherit pub_methods_classuvw_1_1Emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a short-lived listener with the event emitter.  <a href="classuvw_1_1Emitter.html#a79e4ed59b5bb5cdc5ee4b0dd71a38472">More...</a><br /></td></tr>
<tr class="separator:a79e4ed59b5bb5cdc5ee4b0dd71a38472 inherit pub_methods_classuvw_1_1Emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c98ab223b4367073d96c51ee3d6a0d1 inherit pub_methods_classuvw_1_1Emitter"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Emitter.html#a4c98ab223b4367073d96c51ee3d6a0d1">erase</a> (Connection&lt; E &gt; conn) noexcept</td></tr>
<tr class="memdesc:a4c98ab223b4367073d96c51ee3d6a0d1 inherit pub_methods_classuvw_1_1Emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects a listener from the event emitter.  <a href="classuvw_1_1Emitter.html#a4c98ab223b4367073d96c51ee3d6a0d1">More...</a><br /></td></tr>
<tr class="separator:a4c98ab223b4367073d96c51ee3d6a0d1 inherit pub_methods_classuvw_1_1Emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d332776a2e35049549a723f35d88912 inherit pub_methods_classuvw_1_1Emitter"><td class="memItemLeft" align="right" valign="top"><a id="a3d332776a2e35049549a723f35d88912"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Emitter.html#a3d332776a2e35049549a723f35d88912">clear</a> () noexcept</td></tr>
<tr class="memdesc:a3d332776a2e35049549a723f35d88912 inherit pub_methods_classuvw_1_1Emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects all the listeners for the given event type. <br /></td></tr>
<tr class="separator:a3d332776a2e35049549a723f35d88912 inherit pub_methods_classuvw_1_1Emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff321dde35550bb40ab90a787b715cf inherit pub_methods_classuvw_1_1Emitter"><td class="memItemLeft" align="right" valign="top"><a id="a6ff321dde35550bb40ab90a787b715cf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Emitter.html#a6ff321dde35550bb40ab90a787b715cf">clear</a> () noexcept</td></tr>
<tr class="memdesc:a6ff321dde35550bb40ab90a787b715cf inherit pub_methods_classuvw_1_1Emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects all the listeners. <br /></td></tr>
<tr class="separator:a6ff321dde35550bb40ab90a787b715cf inherit pub_methods_classuvw_1_1Emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2178cfdcc8b19baa6d7e1f950c7b65c4 inherit pub_methods_classuvw_1_1Emitter"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Emitter.html#a2178cfdcc8b19baa6d7e1f950c7b65c4">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a2178cfdcc8b19baa6d7e1f950c7b65c4 inherit pub_methods_classuvw_1_1Emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there are listeners registered for the specific event.  <a href="classuvw_1_1Emitter.html#a2178cfdcc8b19baa6d7e1f950c7b65c4">More...</a><br /></td></tr>
<tr class="separator:a2178cfdcc8b19baa6d7e1f950c7b65c4 inherit pub_methods_classuvw_1_1Emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15516ea3df907e5e27512d05f64a1cd inherit pub_methods_classuvw_1_1Emitter"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Emitter.html#af15516ea3df907e5e27512d05f64a1cd">empty</a> () const noexcept</td></tr>
<tr class="memdesc:af15516ea3df907e5e27512d05f64a1cd inherit pub_methods_classuvw_1_1Emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there are listeners registered with the event emitter.  <a href="classuvw_1_1Emitter.html#af15516ea3df907e5e27512d05f64a1cd">More...</a><br /></td></tr>
<tr class="separator:af15516ea3df907e5e27512d05f64a1cd inherit pub_methods_classuvw_1_1Emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structuvw_1_1BaseHandle"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structuvw_1_1BaseHandle')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structuvw_1_1BaseHandle.html">uvw::BaseHandle</a></td></tr>
<tr class="memitem:a0d00140c6b4d9f662f8f4590521eebc7 inherit pub_methods_structuvw_1_1BaseHandle"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceuvw.html#aa3ae4a038de60a69b2513a039add1e48">HandleCategory</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuvw_1_1BaseHandle.html#a0d00140c6b4d9f662f8f4590521eebc7">category</a> () const noexcept=0</td></tr>
<tr class="memdesc:a0d00140c6b4d9f662f8f4590521eebc7 inherit pub_methods_structuvw_1_1BaseHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the category of the handle.  <a href="structuvw_1_1BaseHandle.html#a0d00140c6b4d9f662f8f4590521eebc7">More...</a><br /></td></tr>
<tr class="separator:a0d00140c6b4d9f662f8f4590521eebc7 inherit pub_methods_structuvw_1_1BaseHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9771dcd6699b033ee484837a6419b195 inherit pub_methods_structuvw_1_1BaseHandle"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceuvw.html#ad8b4c4aaf16bbe0b08218b42fbf32f0e">HandleType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuvw_1_1BaseHandle.html#a9771dcd6699b033ee484837a6419b195">type</a> () const noexcept=0</td></tr>
<tr class="memdesc:a9771dcd6699b033ee484837a6419b195 inherit pub_methods_structuvw_1_1BaseHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of the handle.  <a href="structuvw_1_1BaseHandle.html#a9771dcd6699b033ee484837a6419b195">More...</a><br /></td></tr>
<tr class="separator:a9771dcd6699b033ee484837a6419b195 inherit pub_methods_structuvw_1_1BaseHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e2c8bd8bea0bfe3cd0bf22befbf9e6 inherit pub_methods_structuvw_1_1BaseHandle"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuvw_1_1BaseHandle.html#af8e2c8bd8bea0bfe3cd0bf22befbf9e6">active</a> () const noexcept=0</td></tr>
<tr class="memdesc:af8e2c8bd8bea0bfe3cd0bf22befbf9e6 inherit pub_methods_structuvw_1_1BaseHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the handle is active.  <a href="structuvw_1_1BaseHandle.html#af8e2c8bd8bea0bfe3cd0bf22befbf9e6">More...</a><br /></td></tr>
<tr class="separator:af8e2c8bd8bea0bfe3cd0bf22befbf9e6 inherit pub_methods_structuvw_1_1BaseHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52ea3d010c19fa5fa3effe2e0d14e0b inherit pub_methods_structuvw_1_1BaseHandle"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuvw_1_1BaseHandle.html#af52ea3d010c19fa5fa3effe2e0d14e0b">closing</a> () const noexcept=0</td></tr>
<tr class="memdesc:af52ea3d010c19fa5fa3effe2e0d14e0b inherit pub_methods_structuvw_1_1BaseHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a handle is closing or closed.  <a href="structuvw_1_1BaseHandle.html#af52ea3d010c19fa5fa3effe2e0d14e0b">More...</a><br /></td></tr>
<tr class="separator:af52ea3d010c19fa5fa3effe2e0d14e0b inherit pub_methods_structuvw_1_1BaseHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60a3ccabd066fc9da06aa458eb62f64 inherit pub_methods_structuvw_1_1BaseHandle"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuvw_1_1BaseHandle.html#ac60a3ccabd066fc9da06aa458eb62f64">referenced</a> () const noexcept=0</td></tr>
<tr class="memdesc:ac60a3ccabd066fc9da06aa458eb62f64 inherit pub_methods_structuvw_1_1BaseHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given handle referenced.  <a href="structuvw_1_1BaseHandle.html#ac60a3ccabd066fc9da06aa458eb62f64">More...</a><br /></td></tr>
<tr class="separator:ac60a3ccabd066fc9da06aa458eb62f64 inherit pub_methods_structuvw_1_1BaseHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classuvw_1_1UnderlyingType"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classuvw_1_1UnderlyingType')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classuvw_1_1UnderlyingType.html">uvw::UnderlyingType&lt; UDPHandle, uv_udp_t &gt;</a></td></tr>
<tr class="memitem:aa711faff7e88895f769f66e8245bda73 inherit pub_static_methods_classuvw_1_1UnderlyingType"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classuvw_1_1UDPHandle.html">UDPHandle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1UnderlyingType.html#aa711faff7e88895f769f66e8245bda73">create</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aa711faff7e88895f769f66e8245bda73 inherit pub_static_methods_classuvw_1_1UnderlyingType"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new resource of the given type.  <a href="classuvw_1_1UnderlyingType.html#aa711faff7e88895f769f66e8245bda73">More...</a><br /></td></tr>
<tr class="separator:aa711faff7e88895f769f66e8245bda73 inherit pub_static_methods_classuvw_1_1UnderlyingType"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classuvw_1_1UDPHandle.html" title="The UDPHandle handle.">UDPHandle</a> handle. </p>
<p>UDP handles encapsulate UDP communication for both clients and servers.<br  />
 By default, <em><a class="el" href="structuvw_1_1IPv4.html" title="The IPv4 tag.">IPv4</a></em> is used as a template parameter. The handle already supports <em><a class="el" href="structuvw_1_1IPv6.html" title="The IPv6 tag.">IPv6</a></em> out-of-the-box by using <code><a class="el" href="structuvw_1_1IPv6.html" title="The IPv6 tag.">uvw::IPv6</a></code>.</p>
<p>To create an <code><a class="el" href="classuvw_1_1UDPHandle.html" title="The UDPHandle handle.">UDPHandle</a></code> through a <code><a class="el" href="classuvw_1_1Loop.html" title="The Loop class.">Loop</a></code>, arguments follow:</p>
<ul>
<li>An optional integer value that indicates optional flags used to initialize the socket.</li>
</ul>
<p>See the official <a href="http://docs.libuv.org/en/v1.x/udp.html#c.uv_udp_init_ex">documentation</a> for further details. </p>

<p class="definition">Definition at line <a class="el" href="udp_8h_source.html#l00093">93</a> of file <a class="el" href="udp_8h_source.html">udp.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a6ce77d17a192d820e9de9bb19b33e563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce77d17a192d820e9de9bb19b33e563">&#9670;&nbsp;</a></span>bind() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I  = IPv4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void uvw::UDPHandle::bind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuvw_1_1Addr.html">Addr</a>&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classuvw_1_1Flags.html">Flags</a>&lt; Bind &gt;&#160;</td>
          <td class="paramname"><em>opts</em> = <code><a class="el" href="classuvw_1_1Flags.html">Flags</a>&lt;&#160;Bind&#160;&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds the UDP handle to an IP address and port. </p>
<p>Available flags are:</p>
<ul>
<li><code>UDPHandle::Bind::IPV6ONLY</code></li>
<li><code>UDPHandle::Bind::UDP_PARTIAL</code></li>
<li><code>UDPHandle::Bind::REUSEADDR</code></li>
<li><code>UDPHandle::Bind::UDP_MMSG_CHUNK</code></li>
<li><code>UDPHandle::Bind::UDP_RECVMMSG</code></li>
</ul>
<p>See the official <a href="http://docs.libuv.org/en/v1.x/udp.html#c.uv_udp_flags">documentation</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>A valid instance of <a class="el" href="structuvw_1_1Addr.html" title="Address representation.">Addr</a>. </td></tr>
    <tr><td class="paramname">opts</td><td>Optional additional flags. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53c7c261aac3305dd607f0a0f4782eb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53c7c261aac3305dd607f0a0f4782eb1">&#9670;&nbsp;</a></span>bind() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uvw::UDPHandle::bind </td>
          <td>(</td>
          <td class="paramtype">const sockaddr &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classuvw_1_1Flags.html">Flags</a>&lt; Bind &gt;&#160;</td>
          <td class="paramname"><em>opts</em> = <code><a class="el" href="classuvw_1_1Flags.html">Flags</a>&lt;&#160;Bind&#160;&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds the UDP handle to an IP address and port. </p>
<p>Available flags are:</p>
<ul>
<li><code>UDPHandle::Bind::IPV6ONLY</code></li>
<li><code>UDPHandle::Bind::UDP_PARTIAL</code></li>
<li><code>UDPHandle::Bind::REUSEADDR</code></li>
<li><code>UDPHandle::Bind::UDP_RECVMMSG</code></li>
</ul>
<p>See the official <a href="http://docs.libuv.org/en/v1.x/udp.html#c.uv_udp_flags">documentation</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Initialized <code>sockaddr_in</code> or <code>sockaddr_in6</code> data structure. </td></tr>
    <tr><td class="paramname">opts</td><td>Optional additional flags. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57cc7ee394e48ed5f096a0b6b6ab510c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57cc7ee394e48ed5f096a0b6b6ab510c">&#9670;&nbsp;</a></span>bind() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I  = IPv4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void uvw::UDPHandle::bind </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classuvw_1_1Flags.html">Flags</a>&lt; Bind &gt;&#160;</td>
          <td class="paramname"><em>opts</em> = <code><a class="el" href="classuvw_1_1Flags.html">Flags</a>&lt;&#160;Bind&#160;&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds the UDP handle to an IP address and port. </p>
<p>Available flags are:</p>
<ul>
<li><code>UDPHandle::Bind::IPV6ONLY</code></li>
<li><code>UDPHandle::Bind::UDP_PARTIAL</code></li>
<li><code>UDPHandle::Bind::REUSEADDR</code></li>
<li><code>UDPHandle::Bind::UDP_MMSG_CHUNK</code></li>
<li><code>UDPHandle::Bind::UDP_RECVMMSG</code></li>
</ul>
<p>See the official <a href="http://docs.libuv.org/en/v1.x/udp.html#c.uv_udp_flags">documentation</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip</td><td>The IP address to which to bind. </td></tr>
    <tr><td class="paramname">port</td><td>The port to which to bind. </td></tr>
    <tr><td class="paramname">opts</td><td>Optional additional flags. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41a50d9ccea29757480b69bfc0de2374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a50d9ccea29757480b69bfc0de2374">&#9670;&nbsp;</a></span>broadcast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool uvw::UDPHandle::broadcast </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets broadcast on or off. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>True to set broadcast on, false otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True in case of success, false otherwise. </dd></dl>

</div>
</div>
<a id="a439c6e0f4eaa49db4ddd71a3c326f07a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a439c6e0f4eaa49db4ddd71a3c326f07a">&#9670;&nbsp;</a></span>connect() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I  = IPv4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void uvw::UDPHandle::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuvw_1_1Addr.html">Addr</a>&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Associates the handle to a remote address and port (either <a class="el" href="structuvw_1_1IPv4.html" title="The IPv4 tag.">IPv4</a> or <a class="el" href="structuvw_1_1IPv6.html" title="The IPv6 tag.">IPv6</a>). </p>
<p>Every message sent by this handle is automatically sent to the given destination.<br  />
 Trying to call this function on an already connected handle isn't allowed.</p>
<p>An <a class="el" href="structuvw_1_1ErrorEvent.html" title="The ErrorEvent event.">ErrorEvent</a> event is emitted in case of errors during the connection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>A valid instance of <a class="el" href="structuvw_1_1Addr.html" title="Address representation.">Addr</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf587231065893625a14597eb8ab3a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf587231065893625a14597eb8ab3a21">&#9670;&nbsp;</a></span>connect() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uvw::UDPHandle::connect </td>
          <td>(</td>
          <td class="paramtype">const sockaddr &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Associates the handle to a remote address and port (either <a class="el" href="structuvw_1_1IPv4.html" title="The IPv4 tag.">IPv4</a> or <a class="el" href="structuvw_1_1IPv6.html" title="The IPv6 tag.">IPv6</a>). </p>
<p>Every message sent by this handle is automatically sent to the given destination.<br  />
 Trying to call this function on an already connected handle isn't allowed.</p>
<p>An <a class="el" href="structuvw_1_1ErrorEvent.html" title="The ErrorEvent event.">ErrorEvent</a> event is emitted in case of errors during the connection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Initialized <code>sockaddr_in</code> or <code>sockaddr_in6</code> data structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34f636096987eb3fcbe1872f3868c13e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f636096987eb3fcbe1872f3868c13e">&#9670;&nbsp;</a></span>connect() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I  = IPv4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void uvw::UDPHandle::connect </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Associates the handle to a remote address and port (either <a class="el" href="structuvw_1_1IPv4.html" title="The IPv4 tag.">IPv4</a> or <a class="el" href="structuvw_1_1IPv6.html" title="The IPv6 tag.">IPv6</a>). </p>
<p>Every message sent by this handle is automatically sent to the given destination.<br  />
 Trying to call this function on an already connected handle isn't allowed.</p>
<p>An <a class="el" href="structuvw_1_1ErrorEvent.html" title="The ErrorEvent event.">ErrorEvent</a> event is emitted in case of errors during the connection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip</td><td>The address to which to bind. </td></tr>
    <tr><td class="paramname">port</td><td>The port to which to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae0a9ec23746b395ec91b5e62b6b95d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0a9ec23746b395ec91b5e62b6b95d5">&#9670;&nbsp;</a></span>disconnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uvw::UDPHandle::disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disconnects the handle. </p>
<p>Trying to disconnect a handle that is not connected isn't allowed.</p>
<p>An <a class="el" href="structuvw_1_1ErrorEvent.html" title="The ErrorEvent event.">ErrorEvent</a> event is emitted in case of errors. </p>

</div>
</div>
<a id="a07efb83349ed0d28052d74bff7d9eeb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07efb83349ed0d28052d74bff7d9eeb1">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool uvw::UDPHandle::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the handle. The actual socket is created lazily. </p>
<dl class="section return"><dt>Returns</dt><dd>True in case of success, false otherwise. </dd></dl>

</div>
</div>
<a id="a7452f7e65290c913ab6a4df092cd57ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7452f7e65290c913ab6a4df092cd57ee">&#9670;&nbsp;</a></span>multicastInterface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I  = IPv4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool uvw::UDPHandle::multicastInterface </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>iface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the multicast interface to send or receive data on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iface</td><td>Interface address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True in case of success, false otherwise. </dd></dl>

</div>
</div>
<a id="af1736dbefd63e4df9c0a73006ff7ce85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1736dbefd63e4df9c0a73006ff7ce85">&#9670;&nbsp;</a></span>multicastLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool uvw::UDPHandle::multicastLoop </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets IP multicast loop flag. </p>
<p>This makes multicast packets loop back to local sockets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>True to enable multicast loop, false otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True in case of success, false otherwise. </dd></dl>

</div>
</div>
<a id="af4a4f4b90ebf62e8021b03bb5b4dee5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a4f4b90ebf62e8021b03bb5b4dee5b">&#9670;&nbsp;</a></span>multicastMembership()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I  = IPv4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool uvw::UDPHandle::multicastMembership </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>multicast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>iface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Membership&#160;</td>
          <td class="paramname"><em>membership</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets membership for a multicast address. </p>
<p>Available values for <code>membership</code> are:</p>
<ul>
<li><code>UDPHandle::Membership::LEAVE_GROUP</code></li>
<li><code>UDPHandle::Membership::JOIN_GROUP</code></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multicast</td><td>Multicast address to set membership for. </td></tr>
    <tr><td class="paramname">iface</td><td>Interface address. </td></tr>
    <tr><td class="paramname">membership</td><td>Action to be performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True in case of success, false otherwise. </dd></dl>

</div>
</div>
<a id="a70a112900e1beea3c2c636bff6419491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70a112900e1beea3c2c636bff6419491">&#9670;&nbsp;</a></span>multicastTtl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool uvw::UDPHandle::multicastTtl </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the multicast ttl. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>A value in the range <code>[1, 255]</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True in case of success, false otherwise. </dd></dl>

</div>
</div>
<a id="ae833e91e263788861227f91ee65adfd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae833e91e263788861227f91ee65adfd5">&#9670;&nbsp;</a></span>open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uvw::UDPHandle::open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceuvw.html#a2df38e5bba10fc959ef37074cf580097">OSSocketHandle</a>&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens an existing file descriptor or SOCKET as a UDP handle. </p>
<p>The passed file descriptor or SOCKET is not checked for its type, but it’s required that it represents a valid datagram socket.</p>
<p>See the official <a href="http://docs.libuv.org/en/v1.x/udp.html#c.uv_udp_open">documentation</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>A valid socket handle (either a file descriptor or a SOCKET). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a764c71bb11f33f1dd7ac6c0fdc2427db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a764c71bb11f33f1dd7ac6c0fdc2427db">&#9670;&nbsp;</a></span>peer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I  = IPv4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structuvw_1_1Addr.html">Addr</a> uvw::UDPHandle::peer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the remote address to which the handle is connected, if any. </p>
<dl class="section return"><dt>Returns</dt><dd>A valid instance of <a class="el" href="structuvw_1_1Addr.html" title="Address representation.">Addr</a>, an empty one in case of errors. </dd></dl>

</div>
</div>
<a id="a93b0ff1e1375f0d2a3c4425f6a5e5489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93b0ff1e1375f0d2a3c4425f6a5e5489">&#9670;&nbsp;</a></span>recv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I  = IPv4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void uvw::UDPHandle::recv </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepares for receiving data. </p>
<p>Note that if the socket has not previously been bound with <code><a class="el" href="classuvw_1_1UDPHandle.html#a53c7c261aac3305dd607f0a0f4782eb1" title="Binds the UDP handle to an IP address and port.">bind()</a></code>, it is bound to <code>0.0.0.0</code> (the <em>all interfaces</em> <a class="el" href="structuvw_1_1IPv4.html" title="The IPv4 tag.">IPv4</a> address) and a random port number.</p>
<p>An <a class="el" href="structuvw_1_1UDPDataEvent.html" title="UDPDataEvent event.">UDPDataEvent</a> event will be emitted when the handle receives data.<br  />
 An <a class="el" href="structuvw_1_1ErrorEvent.html" title="The ErrorEvent event.">ErrorEvent</a> event will be emitted in case of errors. </p>

</div>
</div>
<a id="a6967ada6a6567b09bd896f33dea56ba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6967ada6a6567b09bd896f33dea56ba2">&#9670;&nbsp;</a></span>send() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I  = IPv4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void uvw::UDPHandle::send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuvw_1_1Addr.html">Addr</a>&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends data over the UDP socket. </p>
<p>Note that if the socket has not previously been bound with <code><a class="el" href="classuvw_1_1UDPHandle.html#a53c7c261aac3305dd607f0a0f4782eb1" title="Binds the UDP handle to an IP address and port.">bind()</a></code>, it will be bound to <code>0.0.0.0</code> (the <em>all interfaces</em> <a class="el" href="structuvw_1_1IPv4.html" title="The IPv4 tag.">IPv4</a> address) and a random port number.</p>
<p>The handle doesn't take the ownership of the data. Be sure that their lifetime overcome the one of the request.</p>
<p>A <a class="el" href="structuvw_1_1SendEvent.html" title="SendEvent event.">SendEvent</a> event will be emitted when the data have been sent.<br  />
 An <a class="el" href="structuvw_1_1ErrorEvent.html" title="The ErrorEvent event.">ErrorEvent</a> event will be emitted in case of errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>A valid instance of <a class="el" href="structuvw_1_1Addr.html" title="Address representation.">Addr</a>. </td></tr>
    <tr><td class="paramname">data</td><td>The data to be sent. </td></tr>
    <tr><td class="paramname">len</td><td>The lenght of the submitted data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a899e92765c79155792032711b589b62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a899e92765c79155792032711b589b62a">&#9670;&nbsp;</a></span>send() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I  = IPv4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void uvw::UDPHandle::send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuvw_1_1Addr.html">Addr</a>&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; char[]&gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends data over the UDP socket. </p>
<p>Note that if the socket has not previously been bound with <code><a class="el" href="classuvw_1_1UDPHandle.html#a53c7c261aac3305dd607f0a0f4782eb1" title="Binds the UDP handle to an IP address and port.">bind()</a></code>, it will be bound to <code>0.0.0.0</code> (the <em>all interfaces</em> <a class="el" href="structuvw_1_1IPv4.html" title="The IPv4 tag.">IPv4</a> address) and a random port number.</p>
<p>The handle takes the ownership of the data and it is in charge of delete them.</p>
<p>A <a class="el" href="structuvw_1_1SendEvent.html" title="SendEvent event.">SendEvent</a> event will be emitted when the data have been sent.<br  />
 An <a class="el" href="structuvw_1_1ErrorEvent.html" title="The ErrorEvent event.">ErrorEvent</a> event will be emitted in case of errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>A valid instance of <a class="el" href="structuvw_1_1Addr.html" title="Address representation.">Addr</a>. </td></tr>
    <tr><td class="paramname">data</td><td>The data to be sent. </td></tr>
    <tr><td class="paramname">len</td><td>The lenght of the submitted data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9855f3277e5a4e1e6a47ec9207d2d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9855f3277e5a4e1e6a47ec9207d2d57">&#9670;&nbsp;</a></span>send() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uvw::UDPHandle::send </td>
          <td>(</td>
          <td class="paramtype">const sockaddr &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends data over the UDP socket. </p>
<p>Note that if the socket has not previously been bound with <code><a class="el" href="classuvw_1_1UDPHandle.html#a53c7c261aac3305dd607f0a0f4782eb1" title="Binds the UDP handle to an IP address and port.">bind()</a></code>, it will be bound to <code>0.0.0.0</code> (the <em>all interfaces</em> <a class="el" href="structuvw_1_1IPv4.html" title="The IPv4 tag.">IPv4</a> address) and a random port number.</p>
<p>The handle doesn't take the ownership of the data. Be sure that their lifetime overcome the one of the request.</p>
<p>A <a class="el" href="structuvw_1_1SendEvent.html" title="SendEvent event.">SendEvent</a> event will be emitted when the data have been sent.<br  />
 An <a class="el" href="structuvw_1_1ErrorEvent.html" title="The ErrorEvent event.">ErrorEvent</a> event will be emitted in case of errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Initialized <code>sockaddr_in</code> or <code>sockaddr_in6</code> data structure. </td></tr>
    <tr><td class="paramname">data</td><td>The data to be sent. </td></tr>
    <tr><td class="paramname">len</td><td>The lenght of the submitted data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8092d01bdd9b790f3ece69ee13ea9a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8092d01bdd9b790f3ece69ee13ea9a28">&#9670;&nbsp;</a></span>send() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uvw::UDPHandle::send </td>
          <td>(</td>
          <td class="paramtype">const sockaddr &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; char[]&gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends data over the UDP socket. </p>
<p>Note that if the socket has not previously been bound with <code><a class="el" href="classuvw_1_1UDPHandle.html#a53c7c261aac3305dd607f0a0f4782eb1" title="Binds the UDP handle to an IP address and port.">bind()</a></code>, it will be bound to <code>0.0.0.0</code> (the <em>all interfaces</em> <a class="el" href="structuvw_1_1IPv4.html" title="The IPv4 tag.">IPv4</a> address) and a random port number.</p>
<p>The handle takes the ownership of the data and it is in charge of delete them.</p>
<p>A <a class="el" href="structuvw_1_1SendEvent.html" title="SendEvent event.">SendEvent</a> event will be emitted when the data have been sent.<br  />
 An <a class="el" href="structuvw_1_1ErrorEvent.html" title="The ErrorEvent event.">ErrorEvent</a> event will be emitted in case of errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Initialized <code>sockaddr_in</code> or <code>sockaddr_in6</code> data structure. </td></tr>
    <tr><td class="paramname">data</td><td>The data to be sent. </td></tr>
    <tr><td class="paramname">len</td><td>The lenght of the submitted data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55884efbab16ac00a157b0bbe5413aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55884efbab16ac00a157b0bbe5413aa6">&#9670;&nbsp;</a></span>send() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I  = IPv4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void uvw::UDPHandle::send </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends data over the UDP socket. </p>
<p>Note that if the socket has not previously been bound with <code><a class="el" href="classuvw_1_1UDPHandle.html#a53c7c261aac3305dd607f0a0f4782eb1" title="Binds the UDP handle to an IP address and port.">bind()</a></code>, it will be bound to <code>0.0.0.0</code> (the <em>all interfaces</em> <a class="el" href="structuvw_1_1IPv4.html" title="The IPv4 tag.">IPv4</a> address) and a random port number.</p>
<p>The handle doesn't take the ownership of the data. Be sure that their lifetime overcome the one of the request.</p>
<p>A <a class="el" href="structuvw_1_1SendEvent.html" title="SendEvent event.">SendEvent</a> event will be emitted when the data have been sent.<br  />
 An <a class="el" href="structuvw_1_1ErrorEvent.html" title="The ErrorEvent event.">ErrorEvent</a> event will be emitted in case of errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip</td><td>The address to which to send data. </td></tr>
    <tr><td class="paramname">port</td><td>The port to which to send data. </td></tr>
    <tr><td class="paramname">data</td><td>The data to be sent. </td></tr>
    <tr><td class="paramname">len</td><td>The lenght of the submitted data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc48b8410e35903b383664191b452bcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc48b8410e35903b383664191b452bcb">&#9670;&nbsp;</a></span>send() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I  = IPv4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void uvw::UDPHandle::send </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; char[]&gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends data over the UDP socket. </p>
<p>Note that if the socket has not previously been bound with <code><a class="el" href="classuvw_1_1UDPHandle.html#a53c7c261aac3305dd607f0a0f4782eb1" title="Binds the UDP handle to an IP address and port.">bind()</a></code>, it will be bound to <code>0.0.0.0</code> (the <em>all interfaces</em> <a class="el" href="structuvw_1_1IPv4.html" title="The IPv4 tag.">IPv4</a> address) and a random port number.</p>
<p>The handle takes the ownership of the data and it is in charge of delete them.</p>
<p>A <a class="el" href="structuvw_1_1SendEvent.html" title="SendEvent event.">SendEvent</a> event will be emitted when the data have been sent.<br  />
 An <a class="el" href="structuvw_1_1ErrorEvent.html" title="The ErrorEvent event.">ErrorEvent</a> event will be emitted in case of errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip</td><td>The address to which to send data. </td></tr>
    <tr><td class="paramname">port</td><td>The port to which to send data. </td></tr>
    <tr><td class="paramname">data</td><td>The data to be sent. </td></tr>
    <tr><td class="paramname">len</td><td>The lenght of the submitted data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a66bcf98d5a258492842fe6ae022fb961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66bcf98d5a258492842fe6ae022fb961">&#9670;&nbsp;</a></span>sendQueueCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t uvw::UDPHandle::sendQueueCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of send requests currently in the queue awaiting to be processed. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of send requests currently in the queue. </dd></dl>

</div>
</div>
<a id="a4e89abbcd88eacf11ada45cd5c65fb3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e89abbcd88eacf11ada45cd5c65fb3e">&#9670;&nbsp;</a></span>sendQueueSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t uvw::UDPHandle::sendQueueSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of bytes queued for sending. </p>
<p>It strictly shows how much information is currently queued.</p>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes queued for sending. </dd></dl>

</div>
</div>
<a id="aa8494b9b51e0f9e7572d758e710e34bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8494b9b51e0f9e7572d758e710e34bb">&#9670;&nbsp;</a></span>sock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I  = IPv4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structuvw_1_1Addr.html">Addr</a> uvw::UDPHandle::sock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the local IP and port of the UDP handle. </p>
<dl class="section return"><dt>Returns</dt><dd>A valid instance of <a class="el" href="structuvw_1_1Addr.html" title="Address representation.">Addr</a>, an empty one in case of errors. </dd></dl>

</div>
</div>
<a id="a942992c0897638726a9cfb470e110a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a942992c0897638726a9cfb470e110a37">&#9670;&nbsp;</a></span>trySend() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I  = IPv4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int uvw::UDPHandle::trySend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuvw_1_1Addr.html">Addr</a>&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends data over the UDP socket. </p>
<p>Same as <code><a class="el" href="classuvw_1_1UDPHandle.html#a8092d01bdd9b790f3ece69ee13ea9a28" title="Sends data over the UDP socket.">send()</a></code>, but it won’t queue a send request if it can’t be completed immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>A valid instance of <a class="el" href="structuvw_1_1Addr.html" title="Address representation.">Addr</a>. </td></tr>
    <tr><td class="paramname">data</td><td>The data to be sent. </td></tr>
    <tr><td class="paramname">len</td><td>The lenght of the submitted data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes written. </dd></dl>

</div>
</div>
<a id="a39c107fe0a7ca4db749dbf2e1fa8d32c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39c107fe0a7ca4db749dbf2e1fa8d32c">&#9670;&nbsp;</a></span>trySend() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I  = IPv4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int uvw::UDPHandle::trySend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuvw_1_1Addr.html">Addr</a>&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; char[]&gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends data over the UDP socket. </p>
<p>Same as <code><a class="el" href="classuvw_1_1UDPHandle.html#a8092d01bdd9b790f3ece69ee13ea9a28" title="Sends data over the UDP socket.">send()</a></code>, but it won’t queue a send request if it can’t be completed immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>A valid instance of <a class="el" href="structuvw_1_1Addr.html" title="Address representation.">Addr</a>. </td></tr>
    <tr><td class="paramname">data</td><td>The data to be sent. </td></tr>
    <tr><td class="paramname">len</td><td>The lenght of the submitted data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes written. </dd></dl>

</div>
</div>
<a id="a46fad3e1568cce4fee79047b579627c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46fad3e1568cce4fee79047b579627c1">&#9670;&nbsp;</a></span>trySend() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I  = IPv4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int uvw::UDPHandle::trySend </td>
          <td>(</td>
          <td class="paramtype">const sockaddr &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends data over the UDP socket. </p>
<p>Same as <code><a class="el" href="classuvw_1_1UDPHandle.html#a8092d01bdd9b790f3ece69ee13ea9a28" title="Sends data over the UDP socket.">send()</a></code>, but it won’t queue a send request if it can’t be completed immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Initialized <code>sockaddr_in</code> or <code>sockaddr_in6</code> data structure. </td></tr>
    <tr><td class="paramname">data</td><td>The data to be sent. </td></tr>
    <tr><td class="paramname">len</td><td>The lenght of the submitted data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes written. </dd></dl>

</div>
</div>
<a id="a57ee2b1d037fd4c2d2f7487076241809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57ee2b1d037fd4c2d2f7487076241809">&#9670;&nbsp;</a></span>trySend() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I  = IPv4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int uvw::UDPHandle::trySend </td>
          <td>(</td>
          <td class="paramtype">const sockaddr &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; char[]&gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends data over the UDP socket. </p>
<p>Same as <code><a class="el" href="classuvw_1_1UDPHandle.html#a8092d01bdd9b790f3ece69ee13ea9a28" title="Sends data over the UDP socket.">send()</a></code>, but it won’t queue a send request if it can’t be completed immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Initialized <code>sockaddr_in</code> or <code>sockaddr_in6</code> data structure. </td></tr>
    <tr><td class="paramname">data</td><td>The data to be sent. </td></tr>
    <tr><td class="paramname">len</td><td>The lenght of the submitted data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes written. </dd></dl>

</div>
</div>
<a id="a6d7de6f96f8c02e16b3146d144c49bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d7de6f96f8c02e16b3146d144c49bc9">&#9670;&nbsp;</a></span>trySend() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I  = IPv4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int uvw::UDPHandle::trySend </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends data over the UDP socket. </p>
<p>Same as <code><a class="el" href="classuvw_1_1UDPHandle.html#a8092d01bdd9b790f3ece69ee13ea9a28" title="Sends data over the UDP socket.">send()</a></code>, but it won’t queue a send request if it can’t be completed immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip</td><td>The address to which to send data. </td></tr>
    <tr><td class="paramname">port</td><td>The port to which to send data. </td></tr>
    <tr><td class="paramname">data</td><td>The data to be sent. </td></tr>
    <tr><td class="paramname">len</td><td>The lenght of the submitted data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes written. </dd></dl>

</div>
</div>
<a id="aa89b82ecf73039581c7207ef1c3d7cfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89b82ecf73039581c7207ef1c3d7cfd">&#9670;&nbsp;</a></span>trySend() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I  = IPv4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int uvw::UDPHandle::trySend </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; char[]&gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends data over the UDP socket. </p>
<p>Same as <code><a class="el" href="classuvw_1_1UDPHandle.html#a8092d01bdd9b790f3ece69ee13ea9a28" title="Sends data over the UDP socket.">send()</a></code>, but it won’t queue a send request if it can’t be completed immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip</td><td>The address to which to send data. </td></tr>
    <tr><td class="paramname">port</td><td>The port to which to send data. </td></tr>
    <tr><td class="paramname">data</td><td>The data to be sent. </td></tr>
    <tr><td class="paramname">len</td><td>The lenght of the submitted data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes written. </dd></dl>

</div>
</div>
<a id="a95c37745be6ee35cb5ba5c2cece2c555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95c37745be6ee35cb5ba5c2cece2c555">&#9670;&nbsp;</a></span>ttl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool uvw::UDPHandle::ttl </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the time to live. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>A value in the range <code>[1, 255]</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True in case of success, false otherwise. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/uvw/<a class="el" href="udp_8h_source.html">udp.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
