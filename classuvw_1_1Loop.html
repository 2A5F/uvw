<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>uvw: uvw::Loop Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">uvw
   &#160;<span id="projectnumber">1.8.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceuvw.html">uvw</a></li><li class="navelem"><a class="el" href="classuvw_1_1Loop.html">Loop</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classuvw_1_1Loop-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">uvw::Loop Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classuvw_1_1Loop.html" title="The Loop class. ">Loop</a> class.  
 <a href="classuvw_1_1Loop.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="loop_8hpp_source.html">loop.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for uvw::Loop:</div>
<div class="dyncontent">
<div class="center"><img src="classuvw_1_1Loop__inherit__graph.png" border="0" usemap="#uvw_1_1Loop_inherit__map" alt="Inheritance graph"/></div>
<map name="uvw_1_1Loop_inherit__map" id="uvw_1_1Loop_inherit__map">
<area shape="rect" id="node2" href="classuvw_1_1Emitter.html" title="uvw::Emitter\&lt; Loop \&gt;" alt="" coords="5,5,153,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for uvw::Loop:</div>
<div class="dyncontent">
<div class="center"><img src="classuvw_1_1Loop__coll__graph.png" border="0" usemap="#uvw_1_1Loop_coll__map" alt="Collaboration graph"/></div>
<map name="uvw_1_1Loop_coll__map" id="uvw_1_1Loop_coll__map">
<area shape="rect" id="node2" href="classuvw_1_1Emitter.html" title="uvw::Emitter\&lt; Loop \&gt;" alt="" coords="5,5,153,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad0fac96934f7ea2a19d16bc6502aeec9"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ad0fac96934f7ea2a19d16bc6502aeec9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1Loop.html#ad0fac96934f7ea2a19d16bc6502aeec9">configure</a> (Configure flag, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ad0fac96934f7ea2a19d16bc6502aeec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets additional loop options.  <a href="#ad0fac96934f7ea2a19d16bc6502aeec9">More...</a><br /></td></tr>
<tr class="separator:ad0fac96934f7ea2a19d16bc6502aeec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3898884e2019aa052235377dcd03c0f3"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Args&gt; </td></tr>
<tr class="memitem:a3898884e2019aa052235377dcd03c0f3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="structuvw_1_1BaseHandle.html">BaseHandle</a>, R &gt;::value, std::shared_ptr&lt; R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1Loop.html#a3898884e2019aa052235377dcd03c0f3">resource</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3898884e2019aa052235377dcd03c0f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates resources of handles' types.  <a href="#a3898884e2019aa052235377dcd03c0f3">More...</a><br /></td></tr>
<tr class="separator:a3898884e2019aa052235377dcd03c0f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6796643be1a5bdfad719591b0f1a55"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Args&gt; </td></tr>
<tr class="memitem:a6c6796643be1a5bdfad719591b0f1a55"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; not std::is_base_of&lt; <a class="el" href="structuvw_1_1BaseHandle.html">BaseHandle</a>, R &gt;::value, std::shared_ptr&lt; R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1Loop.html#a6c6796643be1a5bdfad719591b0f1a55">resource</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a6c6796643be1a5bdfad719591b0f1a55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates resources of types other than handles' ones.  <a href="#a6c6796643be1a5bdfad719591b0f1a55">More...</a><br /></td></tr>
<tr class="separator:a6c6796643be1a5bdfad719591b0f1a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0dbd76098075f5a187256834df568c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Loop.html#ae0dbd76098075f5a187256834df568c3">close</a> ()</td></tr>
<tr class="memdesc:ae0dbd76098075f5a187256834df568c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases all internal loop resources.  <a href="#ae0dbd76098075f5a187256834df568c3">More...</a><br /></td></tr>
<tr class="separator:ae0dbd76098075f5a187256834df568c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86d06ae9f91d8b48d1d5358040f2547"><td class="memTemplParams" colspan="2">template&lt;Mode mode = Mode::DEFAULT&gt; </td></tr>
<tr class="memitem:aa86d06ae9f91d8b48d1d5358040f2547"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1Loop.html#aa86d06ae9f91d8b48d1d5358040f2547">run</a> () noexcept</td></tr>
<tr class="memdesc:aa86d06ae9f91d8b48d1d5358040f2547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the event loop.  <a href="#aa86d06ae9f91d8b48d1d5358040f2547">More...</a><br /></td></tr>
<tr class="separator:aa86d06ae9f91d8b48d1d5358040f2547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf73136457c892dad414342c8648e6c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Loop.html#adf73136457c892dad414342c8648e6c1">alive</a> () const noexcept</td></tr>
<tr class="memdesc:adf73136457c892dad414342c8648e6c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there are active resources.  <a href="#adf73136457c892dad414342c8648e6c1">More...</a><br /></td></tr>
<tr class="separator:adf73136457c892dad414342c8648e6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e9ff32011351d8cf99b0b3924a670df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Loop.html#a8e9ff32011351d8cf99b0b3924a670df">stop</a> () noexcept</td></tr>
<tr class="memdesc:a8e9ff32011351d8cf99b0b3924a670df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the event loop.  <a href="#a8e9ff32011351d8cf99b0b3924a670df">More...</a><br /></td></tr>
<tr class="separator:a8e9ff32011351d8cf99b0b3924a670df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78ffc161590ea88902c867ef716d0a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Loop.html#ac78ffc161590ea88902c867ef716d0a2">descriptor</a> () const noexcept</td></tr>
<tr class="memdesc:ac78ffc161590ea88902c867ef716d0a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get backend file descriptor.  <a href="#ac78ffc161590ea88902c867ef716d0a2">More...</a><br /></td></tr>
<tr class="separator:ac78ffc161590ea88902c867ef716d0a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa815a8db94b2beb2d23448fe81cf648c"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, Time &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Loop.html#aa815a8db94b2beb2d23448fe81cf648c">timeout</a> () const noexcept</td></tr>
<tr class="memdesc:aa815a8db94b2beb2d23448fe81cf648c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the poll timeout.  <a href="#aa815a8db94b2beb2d23448fe81cf648c">More...</a><br /></td></tr>
<tr class="separator:aa815a8db94b2beb2d23448fe81cf648c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1a1000e23e7d1e849a21fd79b86be9"><td class="memItemLeft" align="right" valign="top">Time&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Loop.html#abb1a1000e23e7d1e849a21fd79b86be9">now</a> () const noexcept</td></tr>
<tr class="memdesc:abb1a1000e23e7d1e849a21fd79b86be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current timestamp in milliseconds.  <a href="#abb1a1000e23e7d1e849a21fd79b86be9">More...</a><br /></td></tr>
<tr class="separator:abb1a1000e23e7d1e849a21fd79b86be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080af72a50c18b92bb50e89afa116e57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Loop.html#a080af72a50c18b92bb50e89afa116e57">update</a> () const noexcept</td></tr>
<tr class="memdesc:a080af72a50c18b92bb50e89afa116e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the event loop’s concept of <em>now</em>.  <a href="#a080af72a50c18b92bb50e89afa116e57">More...</a><br /></td></tr>
<tr class="separator:a080af72a50c18b92bb50e89afa116e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699f41c1c1d31a65c5d12adacdbb94e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Loop.html#a699f41c1c1d31a65c5d12adacdbb94e1">walk</a> (std::function&lt; void(<a class="el" href="structuvw_1_1BaseHandle.html">BaseHandle</a> &amp;)&gt; callback)</td></tr>
<tr class="memdesc:a699f41c1c1d31a65c5d12adacdbb94e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walks the list of handles.  <a href="#a699f41c1c1d31a65c5d12adacdbb94e1">More...</a><br /></td></tr>
<tr class="separator:a699f41c1c1d31a65c5d12adacdbb94e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23471c5025efc9db3cc42f6950f952b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Loop.html#a23471c5025efc9db3cc42f6950f952b1">fork</a> () noexcept</td></tr>
<tr class="memdesc:a23471c5025efc9db3cc42f6950f952b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinitialize any kernel state necessary in the child process after a fork(2) system call.  <a href="#a23471c5025efc9db3cc42f6950f952b1">More...</a><br /></td></tr>
<tr class="separator:a23471c5025efc9db3cc42f6950f952b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07480967d95c0f9908fc75292b07c858"><td class="memTemplParams" colspan="2">template&lt;typename R  = void&gt; </td></tr>
<tr class="memitem:a07480967d95c0f9908fc75292b07c858"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1Loop.html#a07480967d95c0f9908fc75292b07c858">data</a> () const</td></tr>
<tr class="memdesc:a07480967d95c0f9908fc75292b07c858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets user-defined data. <code>uvw</code> won't use this field in any case.  <a href="#a07480967d95c0f9908fc75292b07c858">More...</a><br /></td></tr>
<tr class="separator:a07480967d95c0f9908fc75292b07c858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab9a0c0d23b615c3f5de7b15d742aaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Loop.html#a8ab9a0c0d23b615c3f5de7b15d742aaf">data</a> (std::shared_ptr&lt; void &gt; uData)</td></tr>
<tr class="memdesc:a8ab9a0c0d23b615c3f5de7b15d742aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets arbitrary data. <code>uvw</code> won't use this field in any case.  <a href="#a8ab9a0c0d23b615c3f5de7b15d742aaf">More...</a><br /></td></tr>
<tr class="separator:a8ab9a0c0d23b615c3f5de7b15d742aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33b64667ba24e94456ed4ec172372c6"><td class="memItemLeft" align="right" valign="top">const uv_loop_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Loop.html#ac33b64667ba24e94456ed4ec172372c6">raw</a> () const noexcept</td></tr>
<tr class="memdesc:ac33b64667ba24e94456ed4ec172372c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the underlying raw data structure.  <a href="#ac33b64667ba24e94456ed4ec172372c6">More...</a><br /></td></tr>
<tr class="separator:ac33b64667ba24e94456ed4ec172372c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7d1f89d6e74b8c542e6de4ef4a1753"><td class="memItemLeft" align="right" valign="top">uv_loop_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Loop.html#a4d7d1f89d6e74b8c542e6de4ef4a1753">raw</a> () noexcept</td></tr>
<tr class="memdesc:a4d7d1f89d6e74b8c542e6de4ef4a1753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the underlying raw data structure.  <a href="#a4d7d1f89d6e74b8c542e6de4ef4a1753">More...</a><br /></td></tr>
<tr class="separator:a4d7d1f89d6e74b8c542e6de4ef4a1753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classuvw_1_1Emitter"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classuvw_1_1Emitter')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classuvw_1_1Emitter.html">uvw::Emitter&lt; Loop &gt;</a></td></tr>
<tr class="memitem:af6ba3eecb542efbef8d62ae905d8a8cd inherit pub_methods_classuvw_1_1Emitter"><td class="memItemLeft" align="right" valign="top">Connection&lt; E &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Emitter.html#af6ba3eecb542efbef8d62ae905d8a8cd">on</a> (Listener&lt; E &gt; f)</td></tr>
<tr class="memdesc:af6ba3eecb542efbef8d62ae905d8a8cd inherit pub_methods_classuvw_1_1Emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a long-lived listener with the event emitter.  <a href="classuvw_1_1Emitter.html#af6ba3eecb542efbef8d62ae905d8a8cd">More...</a><br /></td></tr>
<tr class="separator:af6ba3eecb542efbef8d62ae905d8a8cd inherit pub_methods_classuvw_1_1Emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e4ed59b5bb5cdc5ee4b0dd71a38472 inherit pub_methods_classuvw_1_1Emitter"><td class="memItemLeft" align="right" valign="top">Connection&lt; E &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Emitter.html#a79e4ed59b5bb5cdc5ee4b0dd71a38472">once</a> (Listener&lt; E &gt; f)</td></tr>
<tr class="memdesc:a79e4ed59b5bb5cdc5ee4b0dd71a38472 inherit pub_methods_classuvw_1_1Emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a short-lived listener with the event emitter.  <a href="classuvw_1_1Emitter.html#a79e4ed59b5bb5cdc5ee4b0dd71a38472">More...</a><br /></td></tr>
<tr class="separator:a79e4ed59b5bb5cdc5ee4b0dd71a38472 inherit pub_methods_classuvw_1_1Emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c98ab223b4367073d96c51ee3d6a0d1 inherit pub_methods_classuvw_1_1Emitter"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Emitter.html#a4c98ab223b4367073d96c51ee3d6a0d1">erase</a> (Connection&lt; E &gt; conn) noexcept</td></tr>
<tr class="memdesc:a4c98ab223b4367073d96c51ee3d6a0d1 inherit pub_methods_classuvw_1_1Emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects a listener from the event emitter.  <a href="classuvw_1_1Emitter.html#a4c98ab223b4367073d96c51ee3d6a0d1">More...</a><br /></td></tr>
<tr class="separator:a4c98ab223b4367073d96c51ee3d6a0d1 inherit pub_methods_classuvw_1_1Emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d332776a2e35049549a723f35d88912 inherit pub_methods_classuvw_1_1Emitter"><td class="memItemLeft" align="right" valign="top"><a id="a3d332776a2e35049549a723f35d88912"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Emitter.html#a3d332776a2e35049549a723f35d88912">clear</a> () noexcept</td></tr>
<tr class="memdesc:a3d332776a2e35049549a723f35d88912 inherit pub_methods_classuvw_1_1Emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects all the listeners for the given event type. <br /></td></tr>
<tr class="separator:a3d332776a2e35049549a723f35d88912 inherit pub_methods_classuvw_1_1Emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff321dde35550bb40ab90a787b715cf inherit pub_methods_classuvw_1_1Emitter"><td class="memItemLeft" align="right" valign="top"><a id="a6ff321dde35550bb40ab90a787b715cf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Emitter.html#a6ff321dde35550bb40ab90a787b715cf">clear</a> () noexcept</td></tr>
<tr class="memdesc:a6ff321dde35550bb40ab90a787b715cf inherit pub_methods_classuvw_1_1Emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects all the listeners. <br /></td></tr>
<tr class="separator:a6ff321dde35550bb40ab90a787b715cf inherit pub_methods_classuvw_1_1Emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2178cfdcc8b19baa6d7e1f950c7b65c4 inherit pub_methods_classuvw_1_1Emitter"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Emitter.html#a2178cfdcc8b19baa6d7e1f950c7b65c4">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a2178cfdcc8b19baa6d7e1f950c7b65c4 inherit pub_methods_classuvw_1_1Emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there are listeners registered for the specific event.  <a href="classuvw_1_1Emitter.html#a2178cfdcc8b19baa6d7e1f950c7b65c4">More...</a><br /></td></tr>
<tr class="separator:a2178cfdcc8b19baa6d7e1f950c7b65c4 inherit pub_methods_classuvw_1_1Emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15516ea3df907e5e27512d05f64a1cd inherit pub_methods_classuvw_1_1Emitter"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Emitter.html#af15516ea3df907e5e27512d05f64a1cd">empty</a> () const noexcept</td></tr>
<tr class="memdesc:af15516ea3df907e5e27512d05f64a1cd inherit pub_methods_classuvw_1_1Emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there are listeners registered with the event emitter.  <a href="classuvw_1_1Emitter.html#af15516ea3df907e5e27512d05f64a1cd">More...</a><br /></td></tr>
<tr class="separator:af15516ea3df907e5e27512d05f64a1cd inherit pub_methods_classuvw_1_1Emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae2a1f36aafb919444d933e4a43e78d8f"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classuvw_1_1Loop.html">Loop</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Loop.html#ae2a1f36aafb919444d933e4a43e78d8f">create</a> ()</td></tr>
<tr class="memdesc:ae2a1f36aafb919444d933e4a43e78d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new <a class="el" href="classuvw_1_1Loop.html" title="The Loop class. ">Loop</a> instance.  <a href="#ae2a1f36aafb919444d933e4a43e78d8f">More...</a><br /></td></tr>
<tr class="separator:ae2a1f36aafb919444d933e4a43e78d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a284450b3ef37c62bd7a984c73552d7b8"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classuvw_1_1Loop.html">Loop</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1Loop.html#a284450b3ef37c62bd7a984c73552d7b8">getDefault</a> ()</td></tr>
<tr class="memdesc:a284450b3ef37c62bd7a984c73552d7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the initialized default loop.  <a href="#a284450b3ef37c62bd7a984c73552d7b8">More...</a><br /></td></tr>
<tr class="separator:a284450b3ef37c62bd7a984c73552d7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classuvw_1_1Loop.html" title="The Loop class. ">Loop</a> class. </p>
<p>The event loop is the central part of <code>uvw</code>'s functionalities, as well as <code>libuv</code>'s ones.<br />
 It takes care of polling for I/O and scheduling callbacks to be run based on different sources of events. </p>

<p class="definition">Definition at line <a class="el" href="loop_8hpp_source.html#l00142">142</a> of file <a class="el" href="loop_8hpp_source.html">loop.hpp</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="adf73136457c892dad414342c8648e6c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf73136457c892dad414342c8648e6c1">&#9670;&nbsp;</a></span>alive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool uvw::Loop::alive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if there are active resources. </p>
<dl class="section return"><dt>Returns</dt><dd>True if there are active resources in the loop. </dd></dl>

<p class="definition">Definition at line <a class="el" href="loop_8hpp_source.html#l00314">314</a> of file <a class="el" href="loop_8hpp_source.html">loop.hpp</a>.</p>

</div>
</div>
<a id="ae0dbd76098075f5a187256834df568c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0dbd76098075f5a187256834df568c3">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void uvw::Loop::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases all internal loop resources. </p>
<p>Call this function only when the loop has finished executing and all open handles and requests have been closed, or the loop will emit an error.</p>
<p>An <a class="el" href="structuvw_1_1ErrorEvent.html" title="The ErrorEvent event. ">ErrorEvent</a> will be emitted in case of errors. </p>

<p class="definition">Definition at line <a class="el" href="loop_8hpp_source.html#l00280">280</a> of file <a class="el" href="loop_8hpp_source.html">loop.hpp</a>.</p>

</div>
</div>
<a id="ad0fac96934f7ea2a19d16bc6502aeec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0fac96934f7ea2a19d16bc6502aeec9">&#9670;&nbsp;</a></span>configure()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void uvw::Loop::configure </td>
          <td>(</td>
          <td class="paramtype">Configure&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets additional loop options. </p>
<p>You should normally call this before the first call to uv_run() unless mentioned otherwise.<br />
 Supported options:</p>
<ul>
<li><code>Loop::Configure::BLOCK_SIGNAL</code>: Block a signal when polling for new events. A second argument is required and it is the signal number.</li>
</ul>
<p>An <a class="el" href="structuvw_1_1ErrorEvent.html" title="The ErrorEvent event. ">ErrorEvent</a> will be emitted in case of errors.</p>
<p>See the official <a href="http://docs.libuv.org/en/v1.x/loop.html#c.uv_loop_configure">documentation</a> for further details. </p>

<p class="definition">Definition at line <a class="el" href="loop_8hpp_source.html#l00232">232</a> of file <a class="el" href="loop_8hpp_source.html">loop.hpp</a>.</p>

</div>
</div>
<a id="ae2a1f36aafb919444d933e4a43e78d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2a1f36aafb919444d933e4a43e78d8f">&#9670;&nbsp;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classuvw_1_1Loop.html">Loop</a>&gt; uvw::Loop::create </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new <a class="el" href="classuvw_1_1Loop.html" title="The Loop class. ">Loop</a> instance. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly created loop. </dd></dl>

<p class="definition">Definition at line <a class="el" href="loop_8hpp_source.html#l00161">161</a> of file <a class="el" href="loop_8hpp_source.html">loop.hpp</a>.</p>

</div>
</div>
<a id="a07480967d95c0f9908fc75292b07c858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07480967d95c0f9908fc75292b07c858">&#9670;&nbsp;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;R&gt; uvw::Loop::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets user-defined data. <code>uvw</code> won't use this field in any case. </p>
<dl class="section return"><dt>Returns</dt><dd>User-defined data if any, an invalid pointer otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="loop_8hpp_source.html#l00440">440</a> of file <a class="el" href="loop_8hpp_source.html">loop.hpp</a>.</p>

</div>
</div>
<a id="a8ab9a0c0d23b615c3f5de7b15d742aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ab9a0c0d23b615c3f5de7b15d742aaf">&#9670;&nbsp;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void uvw::Loop::data </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; void &gt;&#160;</td>
          <td class="paramname"><em>uData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets arbitrary data. <code>uvw</code> won't use this field in any case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uData</td><td>User-defined arbitrary data. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="loop_8hpp_source.html#l00448">448</a> of file <a class="el" href="loop_8hpp_source.html">loop.hpp</a>.</p>

</div>
</div>
<a id="ac78ffc161590ea88902c867ef716d0a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac78ffc161590ea88902c867ef716d0a2">&#9670;&nbsp;</a></span>descriptor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int uvw::Loop::descriptor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get backend file descriptor. </p>
<p>Only kqueue, epoll and event ports are supported.<br />
 This can be used in conjunction with <code>run&lt;Loop::Mode::NOWAIT&gt;()</code> to poll in one thread and run the event loop’s callbacks in another.</p>
<dl class="section return"><dt>Returns</dt><dd>The backend file descriptor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="loop_8hpp_source.html#l00339">339</a> of file <a class="el" href="loop_8hpp_source.html">loop.hpp</a>.</p>

</div>
</div>
<a id="a23471c5025efc9db3cc42f6950f952b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23471c5025efc9db3cc42f6950f952b1">&#9670;&nbsp;</a></span>fork()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void uvw::Loop::fork </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reinitialize any kernel state necessary in the child process after a fork(2) system call. </p>
<p>Previously started watchers will continue to be started in the child process.</p>
<p>It is necessary to explicitly call this function on every event loop created in the parent process that you plan to continue to use in the child, including the default loop (even if you don’t continue to use it in the parent). This function must be called before calling any API function using the loop in the child. Failure to do so will result in undefined behaviour, possibly including duplicate events delivered to both parent and child or aborting the child process.</p>
<p>When possible, it is preferred to create a new loop in the child process instead of reusing a loop created in the parent. New loops created in the child process after the fork should not use this function.</p>
<p>Note that this function is not implemented on Windows.<br />
 Note also that this function is experimental in <code>libuv</code>. It may contain bugs, and is subject to change or removal. API and ABI stability is not guaranteed.</p>
<p>An <a class="el" href="structuvw_1_1ErrorEvent.html" title="The ErrorEvent event. ">ErrorEvent</a> will be emitted in case of errors.</p>
<p>See the official <a href="http://docs.libuv.org/en/v1.x/loop.html#c.uv_loop_fork">documentation</a> for further details. </p>

<p class="definition">Definition at line <a class="el" href="loop_8hpp_source.html#l00430">430</a> of file <a class="el" href="loop_8hpp_source.html">loop.hpp</a>.</p>

</div>
</div>
<a id="a284450b3ef37c62bd7a984c73552d7b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a284450b3ef37c62bd7a984c73552d7b8">&#9670;&nbsp;</a></span>getDefault()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classuvw_1_1Loop.html">Loop</a>&gt; uvw::Loop::getDefault </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the initialized default loop. </p>
<p>It may return an empty pointer in case of failure.<br />
 This function is just a convenient way for having a global loop throughout an application, the default loop is in no way different than the ones initialized with <code><a class="el" href="classuvw_1_1Loop.html#ae2a1f36aafb919444d933e4a43e78d8f" title="Initializes a new Loop instance. ">create()</a></code>.<br />
 As such, the default loop can be closed with <code><a class="el" href="classuvw_1_1Loop.html#ae0dbd76098075f5a187256834df568c3" title="Releases all internal loop resources. ">close()</a></code> so the resources associated with it are freed (even if it is not strictly necessary).</p>
<dl class="section return"><dt>Returns</dt><dd>The initialized default loop. </dd></dl>

<p class="definition">Definition at line <a class="el" href="loop_8hpp_source.html#l00184">184</a> of file <a class="el" href="loop_8hpp_source.html">loop.hpp</a>.</p>

</div>
</div>
<a id="abb1a1000e23e7d1e849a21fd79b86be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb1a1000e23e7d1e849a21fd79b86be9">&#9670;&nbsp;</a></span>now()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Time uvw::Loop::now </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current timestamp in milliseconds. </p>
<p>The timestamp is cached at the start of the event loop tick.<br />
 The timestamp increases monotonically from some arbitrary point in time.<br />
 Don’t make assumptions about the starting point, you will only get disappointed.</p>
<dl class="section return"><dt>Returns</dt><dd>The current timestamp in milliseconds (actual type is <code>std::chrono::duration&lt;uint64_t, std::milli&gt;</code>). </dd></dl>

<p class="definition">Definition at line <a class="el" href="loop_8hpp_source.html#l00366">366</a> of file <a class="el" href="loop_8hpp_source.html">loop.hpp</a>.</p>

</div>
</div>
<a id="ac33b64667ba24e94456ed4ec172372c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac33b64667ba24e94456ed4ec172372c6">&#9670;&nbsp;</a></span>raw() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uv_loop_t* uvw::Loop::raw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the underlying raw data structure. </p>
<p>This function should not be used, unless you know exactly what you are doing and what are the risks.<br />
 Going raw is dangerous, mainly because the lifetime management of a loop, a handle or a request is in charge to the library itself and users should not work around it.</p>
<dl class="section warning"><dt>Warning</dt><dd>Use this function at your own risk, but do not expect any support in case of bugs.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The underlying raw data structure. </dd></dl>

<p class="definition">Definition at line <a class="el" href="loop_8hpp_source.html#l00467">467</a> of file <a class="el" href="loop_8hpp_source.html">loop.hpp</a>.</p>

</div>
</div>
<a id="a4d7d1f89d6e74b8c542e6de4ef4a1753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d7d1f89d6e74b8c542e6de4ef4a1753">&#9670;&nbsp;</a></span>raw() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uv_loop_t* uvw::Loop::raw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the underlying raw data structure. </p>
<p>This function should not be used, unless you know exactly what you are doing and what are the risks.<br />
 Going raw is dangerous, mainly because the lifetime management of a loop, a handle or a request is in charge to the library itself and users should not work around it.</p>
<dl class="section warning"><dt>Warning</dt><dd>Use this function at your own risk, but do not expect any support in case of bugs.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The underlying raw data structure. </dd></dl>

<p class="definition">Definition at line <a class="el" href="loop_8hpp_source.html#l00486">486</a> of file <a class="el" href="loop_8hpp_source.html">loop.hpp</a>.</p>

</div>
</div>
<a id="a3898884e2019aa052235377dcd03c0f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3898884e2019aa052235377dcd03c0f3">&#9670;&nbsp;</a></span>resource() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="structuvw_1_1BaseHandle.html">BaseHandle</a>, R&gt;::value, std::shared_ptr&lt;R&gt; &gt; uvw::Loop::resource </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates resources of handles' types. </p>
<p>This should be used as a default method to create resources.<br />
 The arguments are the ones required for the specific resource.</p>
<p>Use it as <code>loop-&gt;resource&lt;<a class="el" href="classuvw_1_1TimerHandle.html" title="The TimerHandle handle. ">uvw::TimerHandle</a>&gt;()</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly created resource. </dd></dl>

<p class="definition">Definition at line <a class="el" href="loop_8hpp_source.html#l00250">250</a> of file <a class="el" href="loop_8hpp_source.html">loop.hpp</a>.</p>

</div>
</div>
<a id="a6c6796643be1a5bdfad719591b0f1a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c6796643be1a5bdfad719591b0f1a55">&#9670;&nbsp;</a></span>resource() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;not std::is_base_of&lt;<a class="el" href="structuvw_1_1BaseHandle.html">BaseHandle</a>, R&gt;::value, std::shared_ptr&lt;R&gt; &gt; uvw::Loop::resource </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates resources of types other than handles' ones. </p>
<p>This should be used as a default method to create resources.<br />
 The arguments are the ones required for the specific resource.</p>
<p>Use it as <code>loop-&gt;resource&lt;<a class="el" href="classuvw_1_1WorkReq.html" title="The WorkReq request. ">uvw::WorkReq</a>&gt;()</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly created resource. </dd></dl>

<p class="definition">Definition at line <a class="el" href="loop_8hpp_source.html#l00268">268</a> of file <a class="el" href="loop_8hpp_source.html">loop.hpp</a>.</p>

</div>
</div>
<a id="aa86d06ae9f91d8b48d1d5358040f2547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa86d06ae9f91d8b48d1d5358040f2547">&#9670;&nbsp;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Mode mode = Mode::DEFAULT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool uvw::Loop::run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Runs the event loop. </p>
<p>Available modes are:</p>
<ul>
<li><code>Loop::Mode::DEFAULT</code>: Runs the event loop until there are no more active and referenced handles or requests.</li>
<li><code>Loop::Mode::ONCE</code>: Poll for i/o once. Note that this function blocks if there are no pending callbacks.</li>
<li><code>Loop::Mode::NOWAIT</code>: Poll for i/o once but don’t block if there are no pending callbacks.</li>
</ul>
<p>See the official <a href="http://docs.libuv.org/en/v1.x/loop.html#c.uv_run">documentation</a> for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>True when done, false in all other cases. </dd></dl>

<p class="definition">Definition at line <a class="el" href="loop_8hpp_source.html#l00304">304</a> of file <a class="el" href="loop_8hpp_source.html">loop.hpp</a>.</p>

</div>
</div>
<a id="a8e9ff32011351d8cf99b0b3924a670df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e9ff32011351d8cf99b0b3924a670df">&#9670;&nbsp;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void uvw::Loop::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stops the event loop. </p>
<p>It causes <code><a class="el" href="classuvw_1_1Loop.html#aa86d06ae9f91d8b48d1d5358040f2547" title="Runs the event loop. ">run()</a></code> to end as soon as possible.<br />
 This will happen not sooner than the next loop iteration.<br />
 If this function was called before blocking for I/O, the loop won’t block for I/O on this iteration. </p>

<p class="definition">Definition at line <a class="el" href="loop_8hpp_source.html#l00326">326</a> of file <a class="el" href="loop_8hpp_source.html">loop.hpp</a>.</p>

</div>
</div>
<a id="aa815a8db94b2beb2d23448fe81cf648c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa815a8db94b2beb2d23448fe81cf648c">&#9670;&nbsp;</a></span>timeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, Time&gt; uvw::Loop::timeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the poll timeout. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>std::pair</code> composed as it follows:<ul>
<li>A boolean value that is true in case of valid timeout, false otherwise.</li>
<li>Milliseconds (<code>std::chrono::duration&lt;uint64_t, std::milli&gt;</code>). </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="loop_8hpp_source.html#l00349">349</a> of file <a class="el" href="loop_8hpp_source.html">loop.hpp</a>.</p>

</div>
</div>
<a id="a080af72a50c18b92bb50e89afa116e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a080af72a50c18b92bb50e89afa116e57">&#9670;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void uvw::Loop::update </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the event loop’s concept of <em>now</em>. </p>
<p>The current time is cached at the start of the event loop tick in order to reduce the number of time-related system calls.<br />
 You won’t normally need to call this function unless you have callbacks that block the event loop for longer periods of time, where <em>longer</em> is somewhat subjective but probably on the order of a millisecond or more. </p>

<p class="definition">Definition at line <a class="el" href="loop_8hpp_source.html#l00379">379</a> of file <a class="el" href="loop_8hpp_source.html">loop.hpp</a>.</p>

</div>
</div>
<a id="a699f41c1c1d31a65c5d12adacdbb94e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a699f41c1c1d31a65c5d12adacdbb94e1">&#9670;&nbsp;</a></span>walk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void uvw::Loop::walk </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(<a class="el" href="structuvw_1_1BaseHandle.html">BaseHandle</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Walks the list of handles. </p>
<p>The callback will be executed once for each handle that is still active.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>A function to be invoked once for each active handle. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="loop_8hpp_source.html#l00390">390</a> of file <a class="el" href="loop_8hpp_source.html">loop.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/uvw/<a class="el" href="loop_8hpp_source.html">loop.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
